$NetBSD: patch-ag,v 1.2 2006/09/22 15:57:47 drochner Exp $

--- sysdeps/freebsd/mem.c.orig	2005-12-12 11:09:39.000000000 +0100
+++ sysdeps/freebsd/mem.c
@@ -28,6 +28,10 @@
 
 #include <glibtop_suid.h>
 
+#if defined(__DragonFly__)
+#include <kinfo.h>
+#endif
+
 #include <sys/sysctl.h>
 #include <sys/vmmeter.h>
 #if defined(__NetBSD__)  && (__NetBSD_Version__ < 105020000)
@@ -58,6 +62,7 @@ static int pageshift;		/* log base 2 of 
 /* define pagetok in terms of pageshift */
 #define pagetok(size) ((size) << pageshift)
 
+#if !defined(__DragonFly__)
 /* nlist structure for kernel access */
 static struct nlist nlst [] = {
 #if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000) || defined(__OpenBSD__)
@@ -75,6 +80,7 @@ static struct nlist nlst [] = {
 	{ 0 }
 #endif
 };
+#endif
 
 /* MIB array for sysctl */
 #ifdef __bsdi__
@@ -83,7 +89,9 @@ static int mib [] = { CTL_VM, VM_TOTAL }
 static int mib [] = { CTL_VM, VM_METER };
 #endif
 
-#if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000) || defined(__OpenBSD__)
+#if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000)
+static int mib_uvmexp [] = { CTL_VM, VM_UVMEXP2 };
+#elif defined(__OpenBSD__)
 static int mib_uvmexp [] = { CTL_VM, VM_UVMEXP };
 #endif
 
@@ -94,10 +102,12 @@ glibtop_init_mem_p (glibtop *server)
 {
 	register int pagesize;
 
+#if !defined(__DragonFly__)
 	if (kvm_nlist (server->machine.kd, nlst) < 0) {
 		glibtop_warn_io_r (server, "kvm_nlist (mem)");
 		return;
 	}
+#endif
 
 	/* get the page size with "getpagesize" and calculate pageshift
 	 * from it */
@@ -119,9 +129,15 @@ glibtop_get_mem_p (glibtop *server, glib
 {
 	struct vmtotal vmt;
 	size_t length_vmt;
-#if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000) || defined(__OpenBSD__)
+#if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000)
+	struct uvmexp_sysctl uvmexp;
+	size_t length_uvmexp;
+#elif defined(__OpenBSD__)
 	struct uvmexp uvmexp;
 	size_t length_uvmexp;
+#elif defined(__DragonFly__)
+	struct vmstats vms;
+	size_t vms_size;
 #else
 	struct vmmeter vmm;
 #endif
@@ -142,11 +158,19 @@ glibtop_get_mem_p (glibtop *server, glib
 	 *         here.] */
 
 	/* Get the data from sysctl */
+#if defined(__DragonFly__)
+	length_vmt = sizeof (vmt);
+	if (sysctlbyname ("vm.vmtotal", &vmt, &length_vmt, NULL, 0)) {
+		glibtop_warn_io_r (server, "sysctl (vmt)");
+		return;
+	}
+#else
 	length_vmt = sizeof (vmt);
 	if (sysctl (mib, 2, &vmt, &length_vmt, NULL, 0)) {
 		glibtop_warn_io_r (server, "sysctl (vmt)");
 		return;
 	}
+#endif
 
 #if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000) || defined(__OpenBSD__)
 	length_uvmexp = sizeof (uvmexp);
@@ -154,6 +178,12 @@ glibtop_get_mem_p (glibtop *server, glib
 		glibtop_warn_io_r (server, "sysctl (uvmexp)");
 		return;
 	}
+#elif defined(__DragonFly__)
+	vms_size = sizeof(vms);
+	if (sysctlbyname("vm.vmstats", &vms, &vms_size, NULL, 0)) {
+		glibtop_warn_io_r (server, "kvm_read (vms)");
+		return;
+	}
 #else
 	/* Get the data from kvm_* */
 	if (kvm_read (server->machine.kd, nlst[1].n_value,
@@ -163,15 +193,24 @@ glibtop_get_mem_p (glibtop *server, glib
 	}
 #endif
 
+#if defined(__DragonFly__)
+	if (kinfo_get_vfs_bufspace(&bufspace)) {
+		glibtop_warn_io_r (server, "kinfo_get_vfs_bufspace");
+		return;
+	}
+#else
 	if (kvm_read (server->machine.kd, nlst[0].n_value,
 		      &bufspace, sizeof (bufspace)) != sizeof (bufspace)) {
 		glibtop_warn_io_r (server, "kvm_read (bufspace)");
 		return;
 	}
+#endif
 
 	/* convert memory stats to Kbytes */
 
-#if defined(__FreeBSD__)
+#if defined(__DragonFly__)
+	v_total_count = vms.v_page_count;
+#elif defined(__FreeBSD__)
 	v_total_count = vmm.v_page_count;
 #else
 #if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000) || defined(__OpenBSD__)
@@ -189,6 +228,9 @@ glibtop_get_mem_p (glibtop *server, glib
 #if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000) || defined(__OpenBSD__)
 	v_used_count = uvmexp.active + uvmexp.inactive;
 	v_free_count = uvmexp.free;
+#elif defined(__DragonFly__)
+	v_used_count = vms.v_active_count + vms.v_inactive_count;
+	v_free_count = vms.v_free_count;
 #else
 	v_used_count = vmm.v_active_count + vmm.v_inactive_count;
 	v_free_count = vmm.v_free_count;
@@ -198,12 +240,16 @@ glibtop_get_mem_p (glibtop *server, glib
 	buf->used  = (guint64) pagetok (v_used_count) << LOG1024;
 	buf->free  = (guint64) pagetok (v_free_count) << LOG1024;
 
-#ifdef __FreeBSD__
+#if defined(__DragonFly__)
+	buf->cached = (guint64) pagetok (vms.v_cache_count) << LOG1024;
+#elif defined(__FreeBSD__)
 	buf->cached = (guint64) pagetok (vmm.v_cache_count) << LOG1024;
 #endif
 
 #if defined(__NetBSD__)  && (__NetBSD_Version__ >= 104000000) || defined(__OpenBSD__)
 	buf->locked = (guint64) pagetok (uvmexp.wired) << LOG1024;
+#elif defined(__DragonFly__)
+	buf->locked = (guint64) pagetok (vms.v_wire_count) << LOG1024;
 #else
 	buf->locked = (guint64) pagetok (vmm.v_wire_count) << LOG1024;
 #endif
