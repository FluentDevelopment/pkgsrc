$NetBSD: patch-ak,v 1.3 2002/07/08 02:21:20 kim Exp $

--- db.c.orig	Thu Jan 31 23:10:27 2002
+++ db.c	Sun Jul  7 21:33:09 2002
@@ -1103,7 +1103,7 @@
 
     if (!db_sequential)
 	fseek(master_file,
-	      (off_t)(MASTER_FIELDS * sizeof(net_long) + DB_LOCK_MESSAGE +
+	      (long)(MASTER_FIELDS * sizeof(net_long) + DB_LOCK_MESSAGE +
 	      GROUP_FIELDS * sizeof(net_long) * gh->group_num), 0);
 
     if (fread((char *)buf, sizeof(net_long), GROUP_FIELDS, master_file) != GROUP_FIELDS)
@@ -1123,7 +1123,7 @@
 #else
     if (!db_sequential)
 	fseek(master_file,
-	      (off_t)(sizeof(master_header) + SAVED_GROUP_HEADER_SIZE(*gh) * gh->group_num), 0);
+	      (long)(sizeof(master_header) + SAVED_GROUP_HEADER_SIZE(*gh) * gh->group_num), 0);
 
     if (fread((char *)gh, SAVED_GROUP_HEADER_SIZE(*gh), 1, master_file) != 1)
 	goto err;
@@ -1145,7 +1145,7 @@
 
     if (!db_sequential)
 	fseek(master_file,
-	      (off_t)(MASTER_FIELDS * sizeof(net_long) + DB_LOCK_MESSAGE +
+	      (long)(MASTER_FIELDS * sizeof(net_long) + DB_LOCK_MESSAGE +
 	      GROUP_FIELDS * sizeof(net_long) * gh->group_num), 0);
 
     buf[0] = gh->first_db_article;
@@ -1163,7 +1163,7 @@
 	goto err;
 #else	/* NETWORK_DATABASE */
     if (!db_sequential)
-	fseek(master_file, (off_t)(sizeof(master_header) + SAVED_GROUP_HEADER_SIZE(*gh) * gh->group_num), 0);
+	fseek(master_file, (long)(sizeof(master_header) + SAVED_GROUP_HEADER_SIZE(*gh) * gh->group_num), 0);
 
 
     if (fwrite((char *)gh, SAVED_GROUP_HEADER_SIZE(*gh), 1, master_file) != 1)
@@ -1348,10 +1348,10 @@
 
 
 #ifndef NOV
-off_t db_read_art(f)
+long db_read_art(f)
 FILE *f;
 {
-    off_t bytes;
+    long bytes;
 
 #ifdef NETWORK_DATABASE
     net_long buf[ARTICLE_FIELDS];
@@ -1556,7 +1556,7 @@
  * fill in db_hdr and db_data from the overview data for the next
  * article in this group.  does weirdo nn encodings of header fields.
  */
-off_t
+long
 db_read_art(f)
 FILE *f;
 {
@@ -1764,32 +1764,32 @@
 }
 
 
-off_t get_index_offset(gh, art_num)
+long get_index_offset(gh, art_num)
 group_header *gh;
 article_number art_num;
 {
 #ifdef NETWORK_DATABASE
-    return (off_t)((art_num - gh->first_db_article) * sizeof(net_long));
+    return (long)((art_num - gh->first_db_article) * sizeof(net_long));
 #else	/* NETWORK_DATABASE */
-    return (off_t)((art_num - gh->first_db_article) * sizeof(off_t));
+    return (long)((art_num - gh->first_db_article) * sizeof(long));
 #endif	/* NETWORK_DATABASE */
 }
 
-off_t get_data_offset(gh, art_num)
+long get_data_offset(gh, art_num)
 group_header *gh;
 article_number art_num;
 {
     FILE *index;
-    off_t data_offset;
+    long data_offset;
 
-    if (gh->first_db_article == art_num) return (off_t)0;
+    if (gh->first_db_article == art_num) return (long)0;
 
     index = open_data_file(gh, 'x', OPEN_READ);
-    if (index == NULL) return (off_t)(-1);
+    if (index == NULL) return (long)(-1);
 
     fseek(index, get_index_offset(gh, art_num), 0);
     if (!db_read_offset(index, &data_offset))
-	data_offset = (off_t)(-1);
+	data_offset = (long)(-1);
 
     fclose(index);
 
@@ -1800,7 +1800,7 @@
 int
 db_read_offset(f, offset)
 FILE *f;
-off_t *offset;
+long *offset;
 {
 #ifdef NETWORK_DATABASE
     net_long temp;
@@ -1813,7 +1813,7 @@
     *offset = temp;
 #else	/* NETWORK_DATABASE */
 
-    if (fread((char *)offset, sizeof(off_t), 1, f) != 1) return 0;
+    if (fread((char *)offset, sizeof(long), 1, f) != 1) return 0;
 #endif	/* NETWORK_DATABASE */
     return 1;
 }
@@ -1821,7 +1821,7 @@
 int
 db_write_offset(f, offset)
 FILE *f;
-off_t *offset;
+long *offset;
 {
 #ifdef NETWORK_DATABASE
     net_long temp;
@@ -1835,7 +1835,7 @@
 
 #else	/* NETWORK_DATABASE */
 
-    if (fwrite((char *)offset, sizeof(off_t), 1, f) != 1) return 0;
+    if (fwrite((char *)offset, sizeof(long), 1, f) != 1) return 0;
 #endif	/* NETWORK_DATABASE */
     return 1;
 }
@@ -1859,7 +1859,7 @@
 int
 db_read_offset(f, offset)
 FILE *f;
-off_t *offset;
+long *offset;
 {
   nn_exitmsg(50, "STUB ROUTINE CALLED: db_read_offset\n");
   return -1;
@@ -1883,7 +1883,7 @@
   return NULL;
 }
 
-off_t
+long
 get_index_offset(gh, art_num)
 group_header *gh;
 article_number art_num;
