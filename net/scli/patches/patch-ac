$NetBSD: patch-ac,v 1.1 2003/05/25 19:55:56 seb Exp $

--- snmp/g_sha.c.orig	Wed Aug 22 14:46:07 2001
+++ snmp/g_sha.c
@@ -124,6 +124,133 @@ SHAInit(SHA_CTX * shaInfo )
   shaInfo->countLo = shaInfo->countHi = 0;
 }
 
+#ifdef __sparc_v9__
+#define nR1(v,w,x,y,z,i) subRound(*v, *w, *x, *y, *z, f1, K1, i)
+#define nR2(v,w,x,y,z,i) subRound(*v, *w, *x, *y, *z, f2, K2, i)
+#define nR3(v,w,x,y,z,i) subRound(*v, *w, *x, *y, *z, f3, K3, i)
+#define nR4(v,w,x,y,z,i) subRound(*v, *w, *x, *y, *z, f4, K4, i)
+
+void doexpand1(guint32 *eData)
+{
+  expand(eData,16); expand(eData,17); expand(eData,18); expand(eData,19);
+  expand(eData,20); expand(eData,21); expand(eData,22); expand(eData,23);
+  expand(eData,24); expand(eData,25); expand(eData,26); expand(eData,27);
+  expand(eData,28); expand(eData,29); expand(eData,30); expand(eData,31);
+  expand(eData,32); expand(eData,33); expand(eData,34); expand(eData,35);
+  expand(eData,36); expand(eData,37); expand(eData,38); expand(eData,39);
+  expand(eData,40); expand(eData,41); expand(eData,42); expand(eData,43);
+  expand(eData,44); expand(eData,45); expand(eData,46); expand(eData,47);
+  expand(eData,48);
+}
+
+void doexpand2(guint32 *eData)
+{
+  expand(eData,49); expand(eData,50); expand(eData,51); expand(eData,52);
+  expand(eData,53); expand(eData,54); expand(eData,55); expand(eData,56);
+  expand(eData,57); expand(eData,58); expand(eData,59); expand(eData,60);
+  expand(eData,61); expand(eData,62); expand(eData,63); expand(eData,64);
+  expand(eData,65); expand(eData,66); expand(eData,67); expand(eData,68);
+  expand(eData,69); expand(eData,70); expand(eData,71); expand(eData,72);
+  expand(eData,73); expand(eData,74); expand(eData,75); expand(eData,76);
+  expand(eData,77); expand(eData,78); expand(eData,79);
+}
+
+void do_R1(guint32 *A, guint32 *B, guint32 *C, guint32 *D, guint32 *E, guint32 *eData)
+{
+  nR1( A, B, C, D, E, eData[ 0] );
+  nR1( E, A, B, C, D, eData[ 1] );
+  nR1( D, E, A, B, C, eData[ 2] );
+  nR1( C, D, E, A, B, eData[ 3] );
+  nR1( B, C, D, E, A, eData[ 4] );
+  nR1( A, B, C, D, E, eData[ 5] );
+  nR1( E, A, B, C, D, eData[ 6] );
+  nR1( D, E, A, B, C, eData[ 7] );
+  nR1( C, D, E, A, B, eData[ 8] );
+  nR1( B, C, D, E, A, eData[ 9] );
+  nR1( A, B, C, D, E, eData[10] );
+  nR1( E, A, B, C, D, eData[11] );
+  nR1( D, E, A, B, C, eData[12] );
+  nR1( C, D, E, A, B, eData[13] );
+  nR1( B, C, D, E, A, eData[14] );
+  nR1( A, B, C, D, E, eData[15] );
+  nR1( E, A, B, C, D, eData[16] );
+  nR1( D, E, A, B, C, eData[17] );
+  nR1( C, D, E, A, B, eData[18] );
+  nR1( B, C, D, E, A, eData[19] );
+}
+
+void do_R2(guint32 *A, guint32 *B, guint32 *C, guint32 *D, guint32 *E, guint32 *eData)
+{
+  nR2( A, B, C, D, E, eData[20]);
+  nR2( E, A, B, C, D, eData[21]);
+  nR2( D, E, A, B, C, eData[22]);
+  nR2( C, D, E, A, B, eData[23]);
+  nR2( B, C, D, E, A, eData[24]);
+  nR2( A, B, C, D, E, eData[25]);
+  nR2( E, A, B, C, D, eData[26]);
+  nR2( D, E, A, B, C, eData[27]);
+  nR2( C, D, E, A, B, eData[28]);
+  nR2( B, C, D, E, A, eData[29]);
+  nR2( A, B, C, D, E, eData[30]);
+  nR2( E, A, B, C, D, eData[31]);
+  nR2( D, E, A, B, C, eData[32]);
+  nR2( C, D, E, A, B, eData[33]);
+  nR2( B, C, D, E, A, eData[34]);
+  nR2( A, B, C, D, E, eData[35]);
+  nR2( E, A, B, C, D, eData[36]);
+  nR2( D, E, A, B, C, eData[37]);
+  nR2( C, D, E, A, B, eData[38]);
+  nR2( B, C, D, E, A, eData[39]);
+}
+
+void do_R3(guint32 *A, guint32 *B, guint32 *C, guint32 *D, guint32 *E, guint32 *eData)
+{
+  nR3( A, B, C, D, E, eData[40]);
+  nR3( E, A, B, C, D, eData[41]);
+  nR3( D, E, A, B, C, eData[42]);
+  nR3( C, D, E, A, B, eData[43]);
+  nR3( B, C, D, E, A, eData[44]);
+  nR3( A, B, C, D, E, eData[45]);
+  nR3( E, A, B, C, D, eData[46]);
+  nR3( D, E, A, B, C, eData[47]);
+  nR3( C, D, E, A, B, eData[48]);
+  nR3( B, C, D, E, A, eData[49]);
+  nR3( A, B, C, D, E, eData[50]);
+  nR3( E, A, B, C, D, eData[51]);
+  nR3( D, E, A, B, C, eData[52]);
+  nR3( C, D, E, A, B, eData[53]);
+  nR3( B, C, D, E, A, eData[54]);
+  nR3( A, B, C, D, E, eData[55]);
+  nR3( E, A, B, C, D, eData[56]);
+  nR3( D, E, A, B, C, eData[57]);
+  nR3( C, D, E, A, B, eData[58]);
+  nR3( B, C, D, E, A, eData[59]);
+}
+
+void do_R4(guint32 *A, guint32 *B, guint32 *C, guint32 *D, guint32 *E, guint32 *eData)
+{
+  nR4( A, B, C, D, E, eData[60]);
+  nR4( E, A, B, C, D, eData[61]);
+  nR4( D, E, A, B, C, eData[62]);
+  nR4( C, D, E, A, B, eData[63]);
+  nR4( B, C, D, E, A, eData[64]);
+  nR4( A, B, C, D, E, eData[65]);
+  nR4( E, A, B, C, D, eData[66]);
+  nR4( D, E, A, B, C, eData[67]);
+  nR4( C, D, E, A, B, eData[68]);
+  nR4( B, C, D, E, A, eData[69]);
+  nR4( A, B, C, D, E, eData[70]);
+  nR4( E, A, B, C, D, eData[71]);
+  nR4( D, E, A, B, C, eData[72]);
+  nR4( C, D, E, A, B, eData[73]);
+  nR4( B, C, D, E, A, eData[74]);
+  nR4( A, B, C, D, E, eData[75]);
+  nR4( E, A, B, C, D, eData[76]);
+  nR4( D, E, A, B, C, eData[77]);
+  nR4( C, D, E, A, B, eData[78]);
+  nR4( B, C, D, E, A, eData[79]);
+}
+#endif /* __sparc_v9__ */
 
 /* Perform the SHA transformation.  Note that this code, like MD5, seems to
    break some optimizing compilers due to the complexity of the expressions
@@ -146,6 +273,14 @@ SHATransform(guint32 *digest, guint32 *d
   E = digest[ 4 ];
   g_memmove( eData, data, SHA_DATASIZE );
 
+#ifdef __sparc_v9__
+  doexpand1(eData);
+  doexpand1(eData);
+  do_R1(&A, &B, &C, &D, &E, eData);
+  do_R2(&A, &B, &C, &D, &E, eData);
+  do_R3(&A, &B, &C, &D, &E, eData);
+  do_R4(&A, &B, &C, &D, &E, eData);
+#else
   /* Heavy mangling, in 4 sub-rounds of 20 interations each. */
   subRound( A, B, C, D, E, f1, K1, eData[  0 ] );
   subRound( E, A, B, C, D, f1, K1, eData[  1 ] );
@@ -230,6 +365,7 @@ SHATransform(guint32 *digest, guint32 *d
   subRound( D, E, A, B, C, f4, K4, expand( eData, 77 ) );
   subRound( C, D, E, A, B, f4, K4, expand( eData, 78 ) );
   subRound( B, C, D, E, A, f4, K4, expand( eData, 79 ) );
+#endif /* __sparc_v9__ */
 
   /* Build message digest */
   digest[ 0 ] += A;
