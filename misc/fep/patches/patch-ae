$NetBSD: patch-ae,v 1.4 2003/11/11 10:42:32 wiz Exp $

--- fep_edit.c.orig	Fri Jan 20 09:16:37 1995
+++ fep_edit.c
@@ -8,7 +8,17 @@ static char rcsid[]=
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/ioctl.h>
+#ifdef TERMIOS
+#include <termios.h>
+#ifdef __linux__
+#ifndef _POSIX_VDISABLE
+#define _POSIX_VDISABLE '\0'
+#endif
+#endif
+#else
 #include <sgtty.h>
+#endif
 #include <sys/time.h>
 #include <ctype.h>
 #include <sys/dir.h>
@@ -25,7 +35,7 @@ int		MarkPosition = -1;	/* Marked positi
 EDITMODE	editmode = NOTYET;	/* edtimode EMACS, VI */
 EDITSTATUS	editstatus = NOTEDITING;/* EDITING, NOTEDITING */
 
-int	maxline = MAXCOMLEN;		/* maximum length of command line */
+int	maxline = MAXCMDLEN;		/* maximum length of command line */
 int	NeedNewLine;			/* add new line flag */
 int	NeedSave;			/* need to save to history */
 int	Transparency = OFF;		/* transparent flag */
@@ -86,7 +96,7 @@ BINDENT emacsBindings[] = {
 	/* ^X-^V	*/	{"\\^X\\^V",	view_buffer},
 	/* ^X-^K	*/	{"\\^X\\^K",	kill_to_top_of_line},
 	/* ^X-^L	*/	{"\\^X\\^L",	fep_repaint},
-	/* ^X-^C	*/	{"\\^X\\^C",	terminate},
+	/* ^X-^C	*/	{"\\^X\\^C",	(FUNC)terminate},
 	/* ^X-^D	*/	{"\\^X\\^D",	send_eof},
 	/* ^X-(		*/	{"\\^X(",	fep_start_script},
 	/* ^X-)		*/	{"\\^X)",	fep_end_script},
@@ -192,6 +202,30 @@ initEmacsBindings (cft, aft)
 
 #define import(table,key,fn) if((int)key>0)table[(int)key]=fn
 
+#ifdef TERMIOS
+    /* Now, using cbreak mode
+    import (cft, initial_ttymode.c_cc[VSTART], ignore);
+    import (cft, initial_ttymode.c_cc[VSTOP], ignore);
+    */
+    import (cft, initial_ttymode.c_cc[VINTR], insert_and_flush);
+    import (cft, initial_ttymode.c_cc[VQUIT], insert_and_flush);
+    /* Now, EOF will be sent on empty line.
+    import (cft, initial_ttymode.c_cc[VEOF], send_eof);
+    */
+#ifdef VSWTC
+    import (cft, initial_ttymode.c_cc[VSWTC], insert_and_flush);
+#endif
+    import (cft, initial_ttymode.c_cc[VSUSP], insert_and_flush);
+    /* ^Y is used for yank-from-kill-buffer
+    import (cft, initial_ttymode.c_cc[VDSUSP], self_insert);
+    */
+    import (cft, initial_ttymode.c_cc[VREPRINT], reprint);
+    import (cft, initial_ttymode.c_cc[VDISCARD], self_insert);
+    import (cft, initial_ttymode.c_cc[VWERASE], delete_previous_word);
+    import (cft, initial_ttymode.c_cc[VLNEXT], literal_next);
+    import (cft, initial_ttymode.c_cc[VERASE], delete_previous_character);
+    import (cft, initial_ttymode.c_cc[VKILL], delete_line);
+#else
     /* Now, using cbreak mode
     import (cft, tchars_buf.t_startc, ignore);
     import (cft, tchars_buf.t_stopc, ignore);
@@ -212,6 +246,7 @@ initEmacsBindings (cft, aft)
     import (cft, ltchars_buf.t_lnextc, literal_next);
     import (cft, initial_ttymode.sg_erase, delete_previous_character);
     import (cft, initial_ttymode.sg_kill, delete_line);
+#endif
 
 #undef import
 
@@ -257,7 +292,7 @@ RETRY:
 	 */
 	swallow_output();
 
-	if (fgets (CommandLine, MAXCOMLEN, redirect_fp)) {
+	if (fgets (CommandLine, MAXCMDLEN, redirect_fp)) {
 	    ++redirect_line;
 	    execute_command = CommandLine;
 	    goto RETURN;	    
@@ -301,7 +336,11 @@ RETRY:
 	 * call send_eof
 	 */
 	if (
+#ifdef TERMIOS
+	    c == initial_ttymode.c_cc[VEOF]
+#else
 	    c == tchars_buf.t_eofc
+#endif
 	    && curFuncTab[c] != send_eof
 	    && ! look_var ("ignore-eof")
 	    && CommandLine [0] == '\0'
@@ -422,11 +461,11 @@ self_insert(c)
     register int i, nbyte = 1, currentNull;
 #ifdef KANJI
     CHAR byte2;
-#endif KANJI
+#endif /* KANJI */
 
     currentNull = strlen (CommandLine);
 
-    if (currentNull >= maxline) {
+    if (currentNull + 1 >= maxline) {
         errorBell();
 	return (0);
     }
@@ -441,7 +480,7 @@ self_insert(c)
 	nbyte = 2;
     }
     else
-#endif KANJI
+#endif /* KANJI */
 	putChar (c);
     reverse_strcpy (
 	&CommandLine[CurrentPosition] + nbyte,
@@ -453,7 +492,7 @@ self_insert(c)
     if (nbyte > 1) {
 	CommandLine[CurrentPosition - 1] = byte2;
     }
-#endif KANJI
+#endif /* KANJI */
     printS (&CommandLine [CurrentPosition]);
 
     if (CommandLine[CurrentPosition] != '\0') {
@@ -557,7 +596,7 @@ moveto (position)
 #ifdef KANJI
 	    && !(CurrentPosition + 1 == position
 		    && iskanji (CommandLine[CurrentPosition]))
-#endif KANJI
+#endif /* KANJI */
 	)
 	    (void) forward_n_character (1);
 }
@@ -581,10 +620,10 @@ beginning_of_line()
 #ifdef KANJI
 #define INC(i) if(iskanji(CommandLine[i])) i+=2; else i++;
 #define DEC(i) if(i>=2 && iskanji_in_string(CommandLine, i-2)) i-=2; else i--;
-#else KANJI
+#else /* KANJI */
 #define INC(i) i++
 #define DEC(i) i--
-#endif KANJI
+#endif /* KANJI */
 
 /*
  * Move cursor to end of line
@@ -642,7 +681,7 @@ backward_n_character(n)
 	    i--;
 	}
 	else
-#endif KANJI
+#endif /* KANJI */
 	putchar (BS);
 	i--;
     }
@@ -697,7 +736,7 @@ backward_n_word (n)
 	    nchars++;
 	}
     }
-#else KANJI
+#else /* KANJI */
     while (n--) {
 	i--, nchars++;
 	while (i > 0 && !iswordchar (CommandLine [i])) {
@@ -707,7 +746,7 @@ backward_n_word (n)
 	    i--, nchars++;
 	}
     }
-#endif KANJI
+#endif /* KANJI */
     return (backward_n_character (nchars));
 }
 
@@ -758,7 +797,7 @@ backward_n_Word (n)
 	    nchars++;
 	}
     }
-#else KANJI
+#else /* KANJI */
     while (n--) {
 	i--, nchars++;
 	while (i > 0 && !isWordchar (CommandLine [i]))
@@ -766,7 +805,7 @@ backward_n_Word (n)
 	while (i > 0 && isWordchar (CommandLine [i - 1]))
 	    i--, nchars++;
     }
-#endif KANJI
+#endif /* KANJI */
     return (backward_n_character (nchars));
 }
 
@@ -804,7 +843,7 @@ forward_n_character(n)
 	(void) putchar (CommandLine[i++]);
     }
     else
-#endif KANJI
+#endif /* KANJI */
     if (isctlchar(CommandLine[i])) {
 	(void) putchar (unctl (CommandLine [i]));
 	i++;
@@ -819,7 +858,7 @@ forward_n_character(n)
 	    (void) putchar (CommandLine[i++]);
 	}
 	else
-#endif KANJI
+#endif /* KANJI */
 	putChar (CommandLine [i++]);
     }
 
@@ -1000,9 +1039,9 @@ delete_previous_n_character(n)
 	    i -= 2, nbyte += 2;
 	else
 	    i -= 1, nbyte += 1;
-#else KANJI
+#else /* KANJI */
     nbyte = n;
-#endif KANJI
+#endif /* KANJI */
 
     deleteArea = howlong (&CommandLine[CurrentPosition - nbyte], nbyte);
     restArea = howlong (&CommandLine[CurrentPosition], 0);
@@ -1075,7 +1114,7 @@ delete_previous_n_word(n)
 	    nchars++;
 	}
     }
-#else KANJI
+#else /* KANJI */
     while (n--) {
 	i--, nchars++;
 	while (i > 0 && !iswordchar (CommandLine [i]))
@@ -1083,7 +1122,7 @@ delete_previous_n_word(n)
 	while (i > 0 && iswordchar (CommandLine [i - 1]))
 	    i--, nchars++;
     }
-#endif KANJI
+#endif /* KANJI */
 
     return (delete_previous_n_character (nchars));
 }
@@ -1136,7 +1175,7 @@ delete_previous_n_Word(n)
 	    nchars++;
 	}
     }
-#else KANJI
+#else /* KANJI */
     while (n--) {
 	i--, nchars++;
 	while (i > 0 && !isWordchar (CommandLine [i]))
@@ -1144,7 +1183,7 @@ delete_previous_n_Word(n)
 	while (i > 0 && isWordchar (CommandLine [i - 1]))
 	    i--, nchars++;
     }
-#endif KANJI
+#endif /* KANJI */
 
     return (delete_previous_n_character (nchars));
 }
@@ -1183,9 +1222,9 @@ delete_next_n_character (n)
 	    else
 		cp++, nbyte++;
     }
-#else KANJI
+#else /* KANJI */
     nbyte = n;
-#endif KANJI
+#endif /* KANJI */
 
     deleteArea = howlong (&CommandLine[CurrentPosition], nbyte);
     restArea = howlong (&CommandLine[CurrentPosition + nbyte], 0);
@@ -1481,7 +1520,11 @@ insert_and_flush(c)
  */
 send_eof()
 {
+#ifdef TERMIOS
+    char c = initial_ttymode.c_cc[VEOF];
+#else
     char c = tchars_buf.t_eofc;
+#endif
 
     (void) self_insert (c);
     if (isctlchar (c))
@@ -1738,9 +1781,9 @@ expand_file_name ()
 
 # ifdef ALLOCA
   	    fcp = (char *) alloca (strlen (dp->d_name) + 1);
-# else ALLOCA
+# else /* ALLOCA */
   	    fcp = (char *) malloc (strlen (dp->d_name) + 1);
-# endif ALLOCA
+# endif /* ALLOCA */
 	    if (fcp == 0) {
 		fputs ("\r\n", stdout);
 		perror ("alloca:");
@@ -1754,7 +1797,7 @@ expand_file_name ()
     fileList [i] = (char *) 0;
 
     if (*start_expand == '~' && look_var ("expand-tilde")) {
-	char *buf [256], *p;
+	char buf [256], *p;
 
 	strcpy (buf, start_expand);
 	p = x_dirname (buf);
@@ -1801,7 +1844,7 @@ expand_file_name ()
 # ifndef ALLOCA
     for (i = 0; fileList [i]; i++)
 	free (fileList [i]);
-# endif ALLOCA
+# endif /* ALLOCA */
 
     closedir(dirp);
     return (0);
@@ -1929,9 +1972,9 @@ ls (dirp, prefixstring)
 	if (prefix (prefixstring, dp->d_name)) {
 # ifdef ALLOCA
   	    fcp = (char *) alloca (strlen (dp->d_name) + 1);
-# else ALLOCA
+# else /* ALLOCA */
   	    fcp = (char *) malloc (strlen (dp->d_name) + 1);
-# endif ALLOCA
+# endif /* ALLOCA */
 	    if (fcp == 0) {
 		fputs ("\r\n", stdout);
 		perror ("alloca:");
@@ -1975,7 +2018,7 @@ BACK:
 # ifndef ALLOCA
     for (i = 0; fileList [i]; i++)
 	free (fileList [i]);
-# endif ALLOCA
+# endif /* ALLOCA */
     return;
 }
 
@@ -2022,7 +2065,7 @@ list_remote_file (host, pattern)
 	fputs ("\n", stdout);
     }
 }
-#endif RINFO
+#endif /* RINFO */
 
 bind_key (ft, func, s, dfunc)
     FUNC ft[];		/* Function table */
@@ -2032,7 +2075,7 @@ bind_key (ft, func, s, dfunc)
 {
     char tmps[16];
 
-    if (s[0] == '\\' && s[1] == '^' && s[2] != NULL) {
+    if (s[0] == '\\' && s[1] == '^' && s[2] != '\0') {
 	tmps[0] = toctrl (s[2]);
 	strcpy (&tmps[1], &s[3]);
 	s = tmps;
@@ -2042,7 +2085,7 @@ bind_key (ft, func, s, dfunc)
      * If the string contain only one character, put the function to
      * appropriate position in the table.
      */
-    if (*(s+1) == NULL) {
+    if (*(s+1) == '\0') {
 	if (isIndirect (ft[(int) *s]))
 	    free (maskIndirect (ft[(int) *s]));
 
