$NetBSD: patch-ae,v 1.1 2004/09/08 12:48:32 sketch Exp $

--- ai.c.orig	1999-06-30 19:25:02.000000000 +0100
+++ ai.c	2004-09-08 13:41:53.000000000 +0100
@@ -59,12 +59,12 @@
    int tries=0;
 
       /* If in a halfstep, finish it */
-   if(trunc(amonst->x)!=round(amonst->x)) switch(amonst->dir) {
+   if(trunc(amonst->x)!=roundup(amonst->x)) switch(amonst->dir) {
       case LEFT: amonst->x-=0.5; return;
       case RIGHT: amonst->x+=0.5; return;
       default: amonst->dir = directions[(int)rnd(2) + 2];
       }
-   if(trunc(amonst->y)!=round(amonst->y)) switch(amonst->dir) {
+   if(trunc(amonst->y)!=roundup(amonst->y)) switch(amonst->dir) {
       case UP: amonst->y-=0.5; return;
       case DOWN: amonst->y+=0.5; return;
       default: amonst->dir = directions[(int)rnd(2)];
@@ -84,9 +84,9 @@
       /* Find coordinates for new position */
    switch(dir) {
       case UP: y-=0.5; eqy=trunc(y); eqx=trunc(x); break;
-      case DOWN: y+=0.5; eqy=round(y); eqx=trunc(x); break;
+      case DOWN: y+=0.5; eqy=roundup(y); eqx=trunc(x); break;
       case LEFT: x-=0.5; eqy=trunc(y); eqx=trunc(x); break;
-      case RIGHT: x+=0.5; eqy=trunc(y); eqx=round(x); break;
+      case RIGHT: x+=0.5; eqy=trunc(y); eqx=roundup(x); break;
       default: printf("Error: Not a direction\n"); return;
       }
 
@@ -94,7 +94,7 @@
    if(!checkdest(eqx, eqy)) goto tryagain;
 
       /* Check for double half-step */
-   if(trunc(x)!=round(x) && trunc(y)!=round(y)) goto tryagain;
+   if(trunc(x)!=roundup(x) && trunc(y)!=roundup(y)) goto tryagain;
 
       /* Passes all checks */
    amonst->x = x;
@@ -111,12 +111,12 @@
    float dx, dy, dz;
 
       /* If in a halfstep, finish it */
-   if(trunc(amonst->x)!=round(amonst->x)) switch(amonst->dir) {
+   if(trunc(amonst->x)!=roundup(amonst->x)) switch(amonst->dir) {
       case LEFT: amonst->x-=0.5; return;
       case RIGHT: amonst->x+=0.5; return;
       default: amonst->dir = directions[(int)rnd(2) + 2];
       }
-   if(trunc(amonst->y)!=round(amonst->y)) switch(amonst->dir) {
+   if(trunc(amonst->y)!=roundup(amonst->y)) switch(amonst->dir) {
       case UP: amonst->y-=0.5; return;
       case DOWN: amonst->y+=0.5; return;
       default: amonst->dir = directions[(int)rnd(2)];
@@ -136,8 +136,8 @@
    tryagain: /* Come back here to try again */
    tries++;
    if(tries>100) {
-      if(trunc(amonst->x)==round(amonst->x) &&
-         trunc(amonst->y)==round(amonst->y))
+      if(trunc(amonst->x)==roundup(amonst->x) &&
+         trunc(amonst->y)==roundup(amonst->y))
          watchentity(amonst, target);
       return;
       }
@@ -175,7 +175,7 @@
    if(!checkdest(eqx, eqy)) goto tryagain;
 
       /* Be careful of half-steps */
-   if(trunc(x)!=round(x) && trunc(y)!=round(y)) goto tryagain;
+   if(trunc(x)!=roundup(x) && trunc(y)!=roundup(y)) goto tryagain;
 
       /* Done working out new position, assign to character */
    amonst->x = x;
@@ -279,7 +279,7 @@
       printf("I was asked to kill a monster that shouldn't be killed!\n");
       if(amonst->health <= 0) {
          if(data[amonst->type].etype != EFFECT) {
-            maze[round(amonst->y)][round(amonst->x)] = -2; /* Blank */
+            maze[roundup(amonst->y)][roundup(amonst->x)] = -2; /* Blank */
             maze[trunc(amonst->y)][trunc(amonst->x)] = -2; /* Blank */
             }
          draw_tilex2(mainwindow, data[amonst->type].tile[amonst->frame],
@@ -293,8 +293,8 @@
                      bmonst->x*GRIDSIZE, bmonst->y*GRIDSIZE,
                      bmonst->color, bmonst->dir);
          }
-      if(maze[round(amonst->y)][round(amonst->x)]!=-2) {
-         bmonst=&monst[maze[round(amonst->y)][round(amonst->x)]];
+      if(maze[roundup(amonst->y)][roundup(amonst->x)]!=-2) {
+         bmonst=&monst[maze[roundup(amonst->y)][roundup(amonst->x)]];
          draw_tilex2(mainwindow, data[bmonst->type].tile[bmonst->frame],
                      bmonst->x*GRIDSIZE, bmonst->y*GRIDSIZE,
                      bmonst->color, bmonst->dir);
@@ -354,9 +354,9 @@
       else amonst->atspeed=4;
       switch(amonst->dir) {
          case LEFT: fx-=1; x=trunc(fx); y=trunc(fy); break;
-         case RIGHT: fx+=1; x=round(fx); y=trunc(fy); break;
+         case RIGHT: fx+=1; x=roundup(fx); y=trunc(fy); break;
          case UP: fy-=1; y=trunc(fy); x=trunc(fx); break;
-         case DOWN: fy+=1; y=round(fy); x=trunc(fx); break;
+         case DOWN: fy+=1; y=roundup(fy); x=trunc(fx); break;
          }
       icorrectpos(&x, &y);
       if(!checkdest(x, y)) {
@@ -420,8 +420,8 @@
    if(!(amonst->x == target->x || amonst->y == target->y)) return 0;
 
       /* Halfsteps are banned */
-   if(round(amonst->x) != trunc(amonst->x)) return 0;
-   if(round(amonst->y) != trunc(amonst->y)) return 0;
+   if(roundup(amonst->x) != trunc(amonst->x)) return 0;
+   if(roundup(amonst->y) != trunc(amonst->y)) return 0;
 
       /* Force x1, y1 to be smaller pair */
    if(x1 > x2) {
