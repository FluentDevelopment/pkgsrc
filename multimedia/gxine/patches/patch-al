$NetBSD: patch-al,v 1.3 2006/10/17 16:23:47 drochner Exp $

--- src/engine.c.orig	2006-08-11 15:45:07.000000000 +0200
+++ src/engine.c
@@ -36,7 +36,7 @@
 
 se_t *gse; /* global script engine */
 xine_t *xine; /* global xine instance */
-pthread_mutex_t engine_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+pthread_mutex_t engine_lock;
 
 gboolean initialised = FALSE;
 
@@ -300,9 +300,18 @@ static gboolean js_queue_cb (GtkWidget *
   /* js_lock must be recursive since, if the engine is busy, this function
    * WILL be re-entered from the same thread with the lock already held.
    */
-  static pthread_mutex_t js_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
+  static pthread_mutex_t js_lock;
+  static int jslock_inited = 0;
+  pthread_mutexattr_t ma;
   exec_t *js;
 
+  if (!jslock_inited) {
+	  pthread_mutexattr_init(&ma);
+	  pthread_mutexattr_settype(&ma, PTHREAD_MUTEX_RECURSIVE);
+	  pthread_mutex_init(&js_lock, &ma);
+	  jslock_inited++;
+  }
+
   pthread_mutex_lock (&js_lock);
   while ((js = g_async_queue_try_pop (js_queue)))
   {
@@ -428,6 +437,11 @@ void engine_init (void)
 {
   char *cfgfilename;
   GtkWidget *w;
+  pthread_mutexattr_t ma;
+
+  pthread_mutexattr_init(&ma);
+  pthread_mutexattr_settype(&ma, PTHREAD_MUTEX_RECURSIVE);
+  pthread_mutex_init(&engine_lock, &ma);
 
   /*
    * init the global xine engine
