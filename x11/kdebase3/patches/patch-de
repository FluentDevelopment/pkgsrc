$NetBSD: patch-de,v 1.5 2005/11/08 18:25:44 joerg Exp $

--- ksysguard/ksysguardd/FreeBSD/CPU.c.orig	2005-05-23 12:15:08.000000000 +0000
+++ ksysguard/ksysguardd/FreeBSD/CPU.c
@@ -22,7 +22,10 @@
 #include <osreldate.h>
 
 #include <sys/types.h>
-#if __FreeBSD_version < 500101
+#if defined(__DragonFly__)
+#include <sys/param.h>
+#include <kinfo.h>
+#elif __FreeBSD_version < 500101
 	#include <sys/dkstat.h>
 #else
 	#include <sys/resource.h>
@@ -40,6 +43,18 @@
 #include "Command.h"
 #include "ksysguardd.h"
 
+#if defined(__DragonFly__)
+static void	cputime_percentages(int[4], struct kinfo_cputime *,
+            			    struct kinfo_cputime *);
+static struct kinfo_cputime cp_time, cp_old;
+
+#define	CPUSTATES	4
+#define	CP_USER		0
+#define	CP_NICE		1
+#define	CP_SYS		2
+#define	CP_IDLE		3
+
+#else
 long percentages(int cnt, int *out, long *new, long *old, long *diffs);
 
 unsigned long cp_time_offset;
@@ -47,6 +62,8 @@ unsigned long cp_time_offset;
 long cp_time[CPUSTATES];
 long cp_old[CPUSTATES];
 long cp_diff[CPUSTATES];
+#endif
+
 int cpu_states[CPUSTATES];
 
 void
@@ -73,9 +90,14 @@ exitCpuInfo(void)
 int
 updateCpuInfo(void)
 {
+#if defined(__DragonFly__)
+	kinfo_get_sched_cputime(&cp_time);
+	cputime_percentages(cpu_states, &cp_time, &cp_old);
+#else
 	size_t len = sizeof(cp_time);
         sysctlbyname("kern.cp_time", &cp_time, &len, NULL, 0);
         percentages(CPUSTATES, cpu_states, cp_time, cp_old, cp_diff);
+#endif
 	return (0);
 }
 
@@ -148,7 +170,44 @@ printCPUIdleInfo(const char* cmd)
  *	The routine assumes modulo arithmetic.  This function is especially
  *	useful on BSD mchines for calculating cpu state percentages.
  */
+#if defined(__DragonFly__)
+static void
+cputime_percentages(int out[4], struct kinfo_cputime *new, struct kinfo_cputime * old)
+{
+        struct kinfo_cputime diffs;
+        int i;
+        uint64_t total_change, half_total;
+
+        /* initialization */
+        total_change = 0;
+
+        diffs.cp_user = new->cp_user - old->cp_user;
+        diffs.cp_nice = new->cp_nice - old->cp_nice;
+        diffs.cp_sys = new->cp_sys - old->cp_sys;
+        diffs.cp_intr = new->cp_intr - old->cp_intr;
+        diffs.cp_idle = new->cp_idle - old->cp_idle;
+        total_change = diffs.cp_user + diffs.cp_nice + diffs.cp_sys +
+            diffs.cp_intr + diffs.cp_idle;
+        old->cp_user = new->cp_user;
+        old->cp_nice = new->cp_nice;
+        old->cp_sys = new->cp_sys;
+        old->cp_intr = new->cp_intr;
+        old->cp_idle = new->cp_idle;
+
+        /* avoid divide by zero potential */
+        if (total_change == 0)
+                total_change = 1;
+
+        /* calculate percentages based on overall change, rounding up */
+        half_total = total_change >> 1;
+
+        out[0] = ((diffs.cp_user * 1000LL + half_total) / total_change);
+        out[1] = ((diffs.cp_nice * 1000LL + half_total) / total_change);
+        out[2] = (((diffs.cp_sys + diffs.cp_intr) * 1000LL + half_total) / total_change);
+        out[4] = ((diffs.cp_idle * 1000LL + half_total) / total_change);
+}
 
+#else
 long percentages(cnt, out, new, old, diffs)
 
 int cnt;
@@ -201,3 +260,4 @@ long *diffs;
     /* return the total in case the caller wants to use it */
     return(total_change);
 }
+#endif
