$NetBSD: patch-bc,v 1.3 2006/01/08 14:51:11 abs Exp $

--- include/Xos_r.h.orig	2004-04-23 19:43:05.000000000 +0100
+++ include/Xos_r.h
@@ -205,6 +205,9 @@ extern void XtProcessUnlock(
 # undef _POSIX_THREAD_SAFE_FUNCTIONS
 #endif
 
+#if defined(__DragonFly__)
+#define XNO_MTSAFE_PWDAPI 1
+#endif
 
 /***** <pwd.h> wrappers *****/
 
@@ -257,7 +260,7 @@ typedef struct {
  */
 
 #if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__) || \
-    defined(__APPLE__)
+    defined(__APPLE__) || defined(__DragonFly__)
 static __inline__ void _Xpw_copyPasswd(_Xgetpwparams p)
 {
    memcpy(&(p).pws, (p).pwp, sizeof(struct passwd));
@@ -335,7 +338,20 @@ typedef struct {
   char pwbuf[X_LINE_MAX];
 } _Xgetpwparams;
 # if defined(_POSIX_REENTRANT_FUNCTIONS) || !defined(SVR4) || defined(Lynx)
-#  ifndef Lynx
+#  if defined(__NetBSD__)
+static __inline__ struct passwd * _XGetpwuid(uid_t u, _Xgetpwparams p)
+{ 
+    struct passwd *pwp;
+    return (getpwuid_r(u, &p.pws, p.pwbuf, sizeof((p).pwbuf), &pwp) == -1)
+							? NULL : &p.pws;
+}   
+static __inline__ struct passwd * _XGetpwnam(const char *n, _Xgetpwparams p)
+{ 
+    struct passwd *pwp;
+    return (getpwnam_r(n, &p.pws, p.pwbuf, sizeof((p).pwbuf), &pwp) == -1)
+							? NULL : &p.pws;
+}   
+#  elif !defined(Lynx)
 #   define _XGetpwuid(u,p) \
 ((getpwuid_r((u),&(p).pws,(p).pwbuf,sizeof((p).pwbuf)) == -1) ? NULL : &(p).pws)
 #   define _XGetpwnam(u,p) \
@@ -427,7 +443,7 @@ typedef int _Xgetservbynameparams; /* du
 /* UnixWare 2.0, or other systems with thread support but no _r API. */
 /* WARNING:  The h_addr_list and s_aliases values are *not* copied! */
 
-#if defined(__NetBSD__) || defined(__FreeBSD__)
+#if defined(__DragonFly__) || defined(__NetBSD__) || defined(__FreeBSD__)
 #include <sys/param.h>
 #endif
 
@@ -652,6 +668,15 @@ extern int _Preaddir_r(DIR *, struct dir
 # elif defined(SVR4)
 /* Pre-POSIX API, returns non-NULL on success. */
 #  define _XReaddir(d,p)	(readdir_r((d), &(p).dir_entry))
+#elif defined(__DragonFly__)
+#  define _XReaddir(d,p)        \
+    ( (_Xos_processLock),                                               \
+      (((p).result = readdir((d))) ?                                    \
+       (memcpy(&((p).dir_entry), (p).result, _DIRENT_MINSIZ((p).result)),     \
+        ((p).result = &(p).dir_entry), 0) :                             \
+       0),                                                              \
+      (_Xos_processUnlock),                                             \
+      (p).result )
 # else
 /* We have no idea what is going on.  Fake it all using process locks. */
 #  define _XReaddir(d,p)	\
