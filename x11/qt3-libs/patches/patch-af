$NetBSD: patch-af,v 1.1 2004/04/16 14:30:45 recht Exp $

--- src/kernel/qclipboard_x11.cpp.orig	2004-02-18 14:22:48.000000000 +0100
+++ src/kernel/qclipboard_x11.cpp	2004-04-15 01:54:07.000000000 +0200
@@ -112,10 +112,6 @@
 
 // event capture mechanism for qt_xclb_wait_for_event
 static bool waiting_for_data = FALSE;
-static bool has_captured_event = FALSE;
-static Window capture_event_win = None;
-static int capture_event_type = -1;
-static XEvent captured_event;
 
 class QClipboardWatcher; // forward decl
 static QClipboardWatcher *selection_watcher = 0;
@@ -432,69 +428,36 @@
 { return inSelectionMode_obsolete; }
 
 
-// event filter function... captures interesting events while
-// qt_xclb_wait_for_event is running the event loop
-static int qt_xclb_event_filter(XEvent *event)
-{
-    if (event->xany.type == capture_event_type &&
-	event->xany.window == capture_event_win) {
-	VDEBUG( "QClipboard: event_filter(): caught event type %d", event->type );
-	has_captured_event = TRUE;
-	captured_event = *event;
-	return 1;
-    }
-
-    return 0;
-}
-
 bool qt_xclb_wait_for_event( Display *dpy, Window win, int type, XEvent *event,
 			     int timeout )
 {
-    if ( waiting_for_data )
-	qFatal( "QClipboard: internal error, qt_xclb_wait_for_event recursed" );
-
-    waiting_for_data = TRUE;
-
     QTime started = QTime::currentTime();
     QTime now = started;
-
-    has_captured_event = FALSE;
-    capture_event_win = win;
-    capture_event_type = type;
-
-    QX11EventFilter old_event_filter = qt_set_x11_event_filter(qt_xclb_event_filter);
+    bool flushed = FALSE;
 
     do {
-	if ( XCheckTypedWindowEvent(dpy,win,type,event) ) {
-	    waiting_for_data = FALSE;
-	    qt_set_x11_event_filter(old_event_filter);
+	if ( XCheckTypedWindowEvent(dpy,win,type,event) )
 	    return TRUE;
-	}
 
 	now = QTime::currentTime();
 	if ( started > now )			// crossed midnight
 	    started = now;
 
-	// 0x08 == ExcludeTimers for X11 only
-	qApp->eventLoop()->processEvents( QEventLoop::ExcludeUserInput |
-					  QEventLoop::ExcludeSocketNotifiers |
-					  QEventLoop::WaitForMore | 0x08 );
-
-	if ( has_captured_event ) {
-	    waiting_for_data = FALSE;
-	    *event = captured_event;
-	    qt_set_x11_event_filter(old_event_filter);
-	    return TRUE;
+	if(!flushed) {
+	    XFlush( dpy );
+	    flushed = TRUE;
 	}
-    } while ( started.msecsTo(now) < timeout );
 
-    waiting_for_data = FALSE;
-    qt_set_x11_event_filter(old_event_filter);
+	// sleep 50ms, so we don't use up CPU cycles all the time.
+	struct timeval usleep_tv;
+	usleep_tv.tv_sec = 0;
+	usleep_tv.tv_usec = 50000;
+	select(0, 0, 0, 0, &usleep_tv);
+    } while ( started.msecsTo(now) < timeout );
 
     return FALSE;
 }
 
-
 static inline int maxSelectionIncr( Display *dpy )
 { return XMaxRequestSize(dpy) > 65536 ? 65536*4 : XMaxRequestSize(dpy)*4 - 100; }
 
