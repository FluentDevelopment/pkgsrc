$NetBSD: patch-al,v 1.1 2005/03/16 18:32:50 rillig Exp $

gcc-2.95.3 cannot handle declarations intermixed with code.

--- app/gdisplay.c.orig	Fri Dec  3 23:16:18 2004
+++ app/gdisplay.c	Wed Mar 16 18:32:58 2005
@@ -90,6 +90,7 @@ gdisplay_new (GImage       *gimage,
   GSList *cur_wid_list;
   char title [MAX_TITLE_BUF];
   int instance;
+  Tag t;
 
   /*  If there isn't an interface, never create a gdisplay  */
   if (no_interface)
@@ -181,7 +182,7 @@ gdisplay_new (GImage       *gimage,
   gdisplays_update_title (gimage->ID); 
 
   /* initialize the projection */
-  Tag t = gimage_tag (gdisp->gimage);
+  t = gimage_tag (gdisp->gimage);
   t = tag_set_alpha (t, ALPHA_YES);
   if (tag_format (t) == FORMAT_INDEXED)
   {   t = tag_set_format (t, FORMAT_RGB);  
@@ -225,11 +226,11 @@ gdisplay_format_title (GImage *gimage,
   int empty = gimage_is_empty (gimage);
   Tag t = gimage_tag (gimage);
   char *alpha_msg = ""; /*"no alpha";*/
+  const char *profile;
   if (layer_has_alpha(gimage->active_layer)){
     alpha_msg = "A"; /*"alpha";*/
   }
 
-  const char *profile;
   if (gimage_get_cms_profile(gimage) != NULL)
   {   profile = cms_get_profile_info(gimage_get_cms_profile(gimage))->description;
   }
@@ -373,6 +374,8 @@ gdisplay_process_area_list (GSList *list
 static void 
 gdisplay_project (GDisplay *display, int x, int y, int w, int h) 
 {   /* realloc projection if  necessary */ 
+    PixelArea image_projection_area;
+    PixelArea display_projection_area;
     if((display->gimage->width != canvas_width(display->projection)) ||
 	    (display->gimage->height != canvas_height(display->projection)) ||
        (canvas_tag(display->projection) != canvas_tag(gimage_projection(display->gimage))))
@@ -400,8 +403,6 @@ gdisplay_project (GDisplay *display, int
 
 
     /* Stefan Klein: temporary solution, just copy projection calculated in gimage */
-    PixelArea image_projection_area;
-    PixelArea display_projection_area;
 
     gimage_construct(display->gimage, x,y,w,h);
     pixelarea_init (&image_projection_area, gimage_projection(display->gimage), x,y,w,h, FALSE);
@@ -1918,7 +1919,9 @@ gdisplay_set_cms_flags(GDisplay *display
 
 gboolean       
 gdisplay_set_colormanaged(GDisplay *display, gboolean colormanaged)
-{   if (colormanaged != display->colormanaged)
+{
+    GString *buffer;
+    if (colormanaged != display->colormanaged)
     {   if ((colormanaged == TRUE) && (gimage_get_cms_profile(display->gimage) == NULL))
         {   g_warning("gdisplay_set_colormanaged: cannot colormanage. no display profile defined");  
    	    return FALSE;
@@ -1930,7 +1933,7 @@ gdisplay_set_colormanaged(GDisplay *disp
 
 	display->colormanaged = colormanaged;
 	/* set the toggle menu */
-	GString *buffer = g_string_new(NULL);
+	buffer = g_string_new(NULL);
 	g_string_sprintf(buffer, "<Image%d>/View/Colormanage Display", display->unique_id);
 	menus_set_state (buffer->str, colormanaged);
 	g_string_free(buffer, TRUE);
@@ -1945,15 +1948,17 @@ gdisplay_set_colormanaged(GDisplay *disp
 
 gboolean 
 gdisplay_all_set_colormanaged(gboolean colormanaged)
-{   if ((colormanaged == TRUE) && (cms_display_profile_name == NULL))
+{
+    gboolean some_without_profile = FALSE; 
+    GSList *list = display_list;
+    GDisplay *current_display;
+    GString *buffer;
+    if ((colormanaged == TRUE) && (cms_display_profile_name == NULL))
     {   g_warning("gdisplay_all_set_colormanaged: cannot colormanage. no display profile defined");    
         return FALSE;
     }
     
-    gboolean some_without_profile = FALSE; 
-    GSList *list = display_list;
-    GDisplay *current_display;
-    GString *buffer = g_string_new(NULL);
+    buffer = g_string_new(NULL);
 
     /*  traverse the linked list of displays  */
     while (list)
@@ -1986,15 +1991,18 @@ gdisplay_all_set_colormanaged(gboolean c
 
 gboolean
 gdisplay_image_set_colormanaged(int image_id, gboolean colormanaged)
-{   if ((colormanaged == TRUE) && (cms_display_profile_name == NULL))
+{
+    gboolean some_without_profile = FALSE; 
+    GSList *list = display_list;
+    GDisplay *current_display;
+    GString *buffer;
+
+    if ((colormanaged == TRUE) && (cms_display_profile_name == NULL))
     {   g_warning("gdisplay_image_set_colormanaged: cannot colormanage. no display profile defined");    
         return FALSE;
     }
     
-    gboolean some_without_profile = FALSE; 
-    GSList *list = display_list;
-    GDisplay *current_display;
-    GString *buffer = g_string_new(NULL);
+    buffer = g_string_new(NULL);
 
     /*  traverse the linked list of displays  */
     while (list)
