$NetBSD: patch-ab,v 1.2 2002/02/27 09:07:43 joda Exp $

--- libidu/walker.c.orig	Wed Jul 17 22:43:41 1996
+++ libidu/walker.c	Wed Feb 27 09:57:28 2002
@@ -33,7 +33,6 @@
 #include "dynvec.h"
 #include "scanners.h"
 #include "pathmax.h"
-#include "xalloca.h"
 
 int walk_dir __P((struct file_link *dir_link));
 struct member_file *get_member_file __P((struct file_link *flink));
@@ -98,7 +97,7 @@
   dirp = opendir (".");
   if (dirp == 0)
     {
-      char *file_name = ALLOCA (char, PATH_MAX);
+      char file_name[PATH_MAX];
       absolute_file_name (file_name, dir_link);
       error (0, errno, _("can't read directory `%s' (`.' from `%s')"), file_name, xgetcwd ());
       return 0;
@@ -116,6 +115,8 @@
 	continue;
 
       flink = get_link_from_dirent (dirent, dir_link);
+      if (flink == 0)
+	break;
       if (!(flink->fl_flags & FL_PRUNE))
 	walk_flink (flink, sub_dirs_vec);
     }
@@ -165,7 +166,7 @@
   if ((old_flags & FL_TYPE_MASK)
       && (old_flags & FL_TYPE_MASK) != (new_flags & FL_TYPE_MASK))
     {
-      char *file_name = ALLOCA (char, PATH_MAX);
+      char file_name[PATH_MAX];
       absolute_file_name (file_name, flink);
       error (0, 0, _("notice: `%s' was a %s, but is now a %s!"), file_name,
 	     (FL_IS_FILE (old_flags) ? _("file") : _("directory")),
@@ -284,8 +285,8 @@
       int alias_ancestry = symlink_ancestry (alias_link);
       if (member->mf_lang_args != alias_member->mf_lang_args)
 	{
-	  char *file_name = ALLOCA (char, PATH_MAX);
-	  char *alias_file_name = ALLOCA (char, PATH_MAX);
+	  char file_name[PATH_MAX];
+	  char alias_file_name[PATH_MAX];
 	  absolute_file_name (file_name, flink);
 	  absolute_file_name (alias_file_name, alias_link);
 	  error (0, 0, _("warning: `%s' and `%s' are the same file, but yield different scans!"),
@@ -380,7 +381,7 @@
 #if 0
       if (member->mf_lang_args != args)
 	{
-	  char *file_name = ALLOCA (char, PATH_MAX);
+	  char file_name[PATH_MAX];
 	  absolute_file_name (file_name, flink);
 	  error (0, 0, _("notice: scan parameters changed for `%s'"), file_name);
 	  member->mf_old_index = -1;
@@ -418,7 +419,7 @@
     {
       if (strchr (args->la_pattern, SLASH_CHAR))
 	{
-	  char *file_name = ALLOCA (char, PATH_MAX);
+	  char file_name[PATH_MAX];
 	  absolute_file_name (file_name, flink);
 	  if (fnmatch (args->la_pattern, file_name, MAYBE_FNM_CASEFOLD | FNM_FILE_NAME) == 0)
 	    return (args->la_language ? args : 0);
@@ -622,7 +623,7 @@
 int
 chdir_to_link (struct file_link *dir_link)
 {
-  char *to_dir_name = ALLOCA (char, PATH_MAX);
+  char to_dir_name[PATH_MAX];
 
   if (current_dir_link == dir_link)
     return 1;
@@ -637,7 +638,7 @@
 	error (0, errno, _("can't chdir to `%s'"), to_dir_name);
       else
 	{
-	  char *from_dir_name = ALLOCA (char, PATH_MAX);
+	  char from_dir_name[PATH_MAX];
 	  absolute_file_name (from_dir_name, current_dir_link);
 	  error (0, errno, _("can't chdir to `%s' from `%s'"), to_dir_name, from_dir_name);
 	}
@@ -811,8 +812,10 @@
 char *
 maybe_relative_file_name (char *buf_0, struct file_link const *to_link, struct file_link const *from_link)
 {
-  struct file_link const **to_link_vec_0 = ALLOCA (struct file_link const *, PATH_MAX/2);
-  struct file_link const **from_link_vec_0 = ALLOCA (struct file_link const *, PATH_MAX/2);
+  struct file_link const *to_link_vec_1[PATH_MAX/2];
+  struct file_link const *from_link_vec_1[PATH_MAX/2];
+  struct file_link const **to_link_vec_0 = to_link_vec_1;
+  struct file_link const **from_link_vec_0 = from_link_vec_1;
   struct file_link const **to_link_vec = to_link_vec_0;
   struct file_link const **from_link_vec = from_link_vec_0;
   struct file_link const **from_link_end;
