$NetBSD: patch-ad,v 1.5 2004/04/19 12:16:08 skrll Exp $

--- pth_syscall.c.orig	Wed Jan  1 15:45:06 2003
+++ pth_syscall.c
@@ -57,6 +57,7 @@
 #define sendto        __pth_sys_sendto
 #define pread         __pth_sys_pread
 #define pwrite        __pth_sys_pwrite
+#define wait4         __pth_sys_wait4
 
 /* include the private header and this way system headers */
 #include "pth_p.h"
@@ -108,6 +109,7 @@ int pth_syscall_hard = PTH_SYSCALL_HARD;
 #undef sendto
 #undef pread
 #undef pwrite
+#undef wait4
 
 /* internal data structures */
 #if cpp
@@ -157,13 +159,18 @@ intern pth_syscall_fct_tab_t pth_syscall
 #define PTH_SCF_sendto        19
 #define PTH_SCF_pread         20
 #define PTH_SCF_pwrite        21
+#define PTH_SCF_wait4         22
     { "fork",        NULL },
     { "waitpid",     NULL },
     { "system",      NULL },
     { "nanosleep",   NULL },
     { "usleep",      NULL },
     { "sleep",       NULL },
+#if defined(__NetBSD__)
+    { "__sigprocmask14", NULL },
+#else
     { "sigprocmask", NULL },
+#endif
     { "sigwait",     NULL },
     { "select",      NULL },
     { "poll",        NULL },
@@ -179,6 +186,7 @@ intern pth_syscall_fct_tab_t pth_syscall
     { "sendto",      NULL },
     { "pread",       NULL },
     { "pwrite",      NULL },
+    { "wait4",       NULL },
     { NULL,          NULL }
 };
 #endif
@@ -405,6 +413,8 @@ intern pid_t pth_sc_waitpid(pid_t wpid, 
                (wpid, status, options);
 #if defined(HAVE_SYSCALL) && defined(SYS_waitpid)
     else return (pid_t)syscall(SYS_waitpid, wpid, status, options);
+#elif defined(HAVE_SYSCALL) && defined(SYS_wait4)
+    else return (pid_t)syscall(SYS_wait4, wpid, status, options, (struct rusage *) NULL);
 #else
     else PTH_SYSCALL_ERROR(-1, ENOSYS, "waitpid");
 #endif
@@ -651,6 +661,52 @@ intern ssize_t pth_sc_recvfrom(int fd, v
 #endif
 }
 
+ssize_t recv(int, void *, size_t, int);
+ssize_t recv(int fd, void *buf, size_t nbytes, int flags)
+{
+    /* external entry point for application */
+    pth_implicit_init();
+    return pth_recv(fd, buf, nbytes, flags);
+}
+intern ssize_t pth_sc_recv(int fd, void *buf, size_t nbytes, int flags)
+{
+    /* internal exit point for Pth */
+    if (pth_syscall_fct_tab[PTH_SCF_recv].addr != NULL)
+        return ((ssize_t (*)(int, void *, size_t, int))
+               pth_syscall_fct_tab[PTH_SCF_recv].addr)
+               (fd, buf, nbytes, flags);
+#if defined(HAVE_SYSCALL) && defined(SYS_recv)
+    else return (ssize_t)syscall(SYS_recv, fd, buf, nbytes, flags);
+#elif defined(HAVE_SYSCALL) && defined(SYS_recvfrom)
+    else return (ssize_t)syscall(SYS_recvfrom, fd, buf, nbytes, flags, (struct sockaddr *) NULL, (socklen_t *) NULL);
+#else
+    else PTH_SYSCALL_ERROR(-1, ENOSYS, "recv");
+#endif
+}
+
+ssize_t send(int, void *, size_t, int);
+ssize_t send(int fd, void *buf, size_t nbytes, int flags)
+{
+    /* external entry point for application */
+    pth_implicit_init();
+    return pth_send(fd, buf, nbytes, flags);
+}
+intern ssize_t pth_sc_send(int fd, void *buf, size_t nbytes, int flags)
+{
+    /* internal exit point for Pth */
+    if (pth_syscall_fct_tab[PTH_SCF_send].addr != NULL)
+        return ((ssize_t (*)(int, void *, size_t, int))
+               pth_syscall_fct_tab[PTH_SCF_send].addr)
+               (fd, buf, nbytes, flags);
+#if defined(HAVE_SYSCALL) && defined(SYS_send)
+    else return (ssize_t)syscall(SYS_send, fd, buf, nbytes, flags);
+#elif defined(HAVE_SYSCALL) && defined(SYS_sendto)
+    else return (ssize_t)syscall(SYS_sendto, fd, buf, nbytes, flags, (struct sockaddr *) NULL, NULL);
+#else
+    else PTH_SYSCALL_ERROR(-1, ENOSYS, "send");
+#endif
+}
+
 /* ==== Pth hard syscall wrapper for sendto(2) ==== */
 ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *, socklen_t);
 ssize_t sendto(int fd, const void *buf, size_t nbytes, int flags, const struct sockaddr *to, socklen_t tolen)
@@ -664,12 +720,34 @@ intern ssize_t pth_sc_sendto(int fd, con
     /* internal exit point for Pth */
     if (pth_syscall_fct_tab[PTH_SCF_sendto].addr != NULL)
         return ((ssize_t (*)(int, const void *, size_t, int, const struct sockaddr *, socklen_t))
-               pth_syscall_fct_tab[PTH_SCF_recvfrom].addr)
+               pth_syscall_fct_tab[PTH_SCF_sendto].addr)
                (fd, buf, nbytes, flags, to, tolen);
 #if defined(HAVE_SYSCALL) && defined(SYS_sendto)
     else return (ssize_t)syscall(SYS_sendto, fd, buf, nbytes, flags, to, tolen);
 #else
     else PTH_SYSCALL_ERROR(-1, ENOSYS, "sendto");
+#endif
+}
+
+/* ==== Pth hard syscall wrapper for wait4(2) ==== */
+pid_t wait4(pid_t, int *, int, struct rusage *);
+pid_t wait4(pid_t wpid, int *status, int options, struct rusage *rusage)
+{
+    /* external entry point for application */
+    pth_implicit_init();
+    return pth_wait4(wpid, status, options, rusage);
+}
+intern pid_t pth_sc_wait4(pid_t wpid, int *status, int options, struct rusage *rusage)
+{
+    /* internal exit point for Pth */
+    if (pth_syscall_fct_tab[PTH_SCF_wait4].addr != NULL)
+        return ((pid_t (*)(pid_t, int *, int, struct rusage *))
+               pth_syscall_fct_tab[PTH_SCF_wait4].addr)
+               (wpid, status, options, rusage);
+#if defined(HAVE_SYSCALL) && defined(SYS_wait4)
+    else return (pid_t)syscall(SYS_wait4, wpid, status, options, rusage);
+#else
+    else PTH_SYSCALL_ERROR(-1, ENOSYS, "wait4");
 #endif
 }
 
