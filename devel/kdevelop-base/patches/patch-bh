$NetBSD: patch-bh,v 1.1 2007/03/24 14:01:30 markd Exp $

--- buildtools/lib/parsers/qmake/qmake_lex.cpp.orig	2007-01-26 04:42:02.000000000 +1300
+++ buildtools/lib/parsers/qmake/qmake_lex.cpp
@@ -14,13 +14,17 @@
 #define FLEX_BETA
 #endif
 
+    /* The c++ scanner is a mess. The FlexLexer.h header file relies on the
+     * following macro. This is required in order to pass the c++-multiple-scanners
+     * test in the regression suite. We get reports that it breaks inheritance.
+     * We will address this in a future release of flex, or omit the C++ scanner
+     * altogether.
+     */
+    #define yyFlexLexer yyFlexLexer
+
 /* First, we deal with  platform-specific or compiler-specific issues. */
 
 /* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
 
 /* end standard C headers. */
 
@@ -87,6 +91,13 @@ typedef unsigned int flex_uint32_t;
 
 #endif /* ! FLEXINT_H */
 
+/* begin standard C++ headers. */
+#include <iostream> 
+#include <errno.h>
+#include <cstdlib>
+#include <cstring>
+/* end standard C++ headers. */
+
 #ifdef __cplusplus
 
 /* The "const" storage-class-modifier is valid. */
@@ -134,7 +145,7 @@ typedef unsigned int flex_uint32_t;
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
+#define YY_NEW_FILE yyrestart( yyin  )
 
 #define YY_END_OF_BUFFER_CHAR 0
 
@@ -154,13 +165,24 @@ typedef struct yy_buffer_state *YY_BUFFE
 
 extern int yyleng;
 
-extern FILE *yyin, *yyout;
-
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-    #define YY_LESS_LINENO(n)
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE yylex. 
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                int yyl;\
+                for ( yyl = n; yyl < yyleng; ++yyl )\
+                    if ( yytext[yyl] == '\n' )\
+                        --yylineno;\
+            }while(0)
     
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
@@ -192,7 +214,8 @@ typedef unsigned int yy_size_t;
 #define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
-	FILE *yy_input_file;
+
+	std::istream* yy_input_file;
 
 	char *yy_ch_buf;		/* input buffer */
 	char *yy_buf_pos;		/* current position in input buffer */
@@ -253,11 +276,6 @@ struct yy_buffer_state
 	};
 #endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
-
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
@@ -273,39 +291,6 @@ static YY_BUFFER_STATE * yy_buffer_stack
  */
 #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
-
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
-
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
-
 void *yyalloc (yy_size_t  );
 void *yyrealloc (void *,yy_size_t  );
 void yyfree (void *  );
@@ -317,7 +302,7 @@ void yyfree (void *  );
 	if ( ! YY_CURRENT_BUFFER ){ \
         yyensure_buffer_stack (); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
@@ -327,7 +312,7 @@ void yyfree (void *  );
 	if ( ! YY_CURRENT_BUFFER ){\
         yyensure_buffer_stack (); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+            yy_create_buffer( yyin, YY_BUF_SIZE ); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
@@ -341,21 +326,17 @@ void yyfree (void *  );
 
 typedef unsigned char YY_CHAR;
 
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-
-int yylineno = 1;
-
-extern char *yytext;
 #define yytext_ptr yytext
+#define YY_INTERACTIVE
 
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-static void yy_fatal_error (yyconst char msg[]  );
+#include <FlexLexer.h>
+int yyFlexLexer::yylex()
+	{
+	LexerError( "yyFlexLexer::yylex invoked but %option yyclass used" );
+	return 0;
+	}
+
+#define YY_DECL int QMake::Lexer::yylex()
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
@@ -376,24 +357,25 @@ struct yy_trans_info
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[79] =
+static yyconst flex_int16_t yy_accept[83] =
     {   0,
         0,    0,    0,    0,    0,    0,    0,    0,   25,   24,
         1,   22,    5,   23,   19,   20,    5,   24,    5,   21,
        11,   24,   16,   18,   24,    9,    2,    9,    9,   24,
         2,    2,    6,    2,   24,    8,    1,    5,    5,   23,
-       14,   12,   13,    0,   17,    0,    4,   15,    9,    0,
-        2,    0,    9,    0,    9,    0,    7,    0,    3,    2,
-        3,    2,    6,    6,    6,    6,    2,    3,    0,    8,
-        9,    0,    9,    0,    0,   10,    0,    0
+       14,   12,   13,    0,   17,    0,    4,    4,   15,    9,
+        0,    2,    0,    9,    0,    0,    9,    0,    7,    7,
+        0,    3,    2,    3,    2,    6,    6,    6,    6,    2,
+        3,    0,    8,    9,    0,    9,    0,    0,   10,    0,
+        7,    0
     } ;
 
 static yyconst flex_int32_t yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    4,    5,    6,    7,    8,    1,    1,    1,    9,
+        1,    2,    5,    6,    7,    8,    1,    1,    1,    9,
        10,   11,   12,    1,   13,   14,    1,   15,   15,   15,
        15,   15,   15,   15,   15,   15,   15,   16,    1,    1,
        17,    1,    1,    1,   18,   18,   18,   18,   18,   18,
@@ -422,122 +404,104 @@ static yyconst flex_int32_t yy_ec[256] =
 
 static yyconst flex_int32_t yy_meta[25] =
     {   0,
-        1,    2,    3,    2,    1,    1,    1,    1,    1,    1,
+        1,    2,    3,    4,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1
     } ;
 
-static yyconst flex_int16_t yy_base[92] =
+static yyconst flex_int16_t yy_base[96] =
     {   0,
-        0,    0,   23,   41,   29,   30,   25,   36,  144,  285,
-       36,  285,   56,    0,  285,  285,  125,  124,  123,   51,
-      285,   47,  285,  285,  122,  119,   50,  118,   77,   95,
-       80,   81,   54,   87,  126,  120,   61,    0,    0,    0,
-      285,  285,  285,   88,  285,   98,  285,  285,  106,   93,
-      101,  104,  113,   67,  131,   74,  285,  149,  285,  109,
-       72,  116,    0,   91,    0,  102,  120,    0,   56,   52,
-      167,  185,  203,  124,  221,  239,  127,  285,  258,  261,
-      264,   58,   40,  266,  269,  271,  273,  275,  278,  280,
-      282
+        0,    0,   23,   41,   26,   29,   31,   36,  158,  202,
+      155,  202,   56,    0,  202,  202,  139,  138,  137,   30,
+      202,   50,  202,  202,  135,  130,   48,   47,   77,   95,
+       55,   56,   71,   70,  137,  131,  131,    0,    0,    0,
+      202,  202,  202,   35,  202,   80,  202,  128,  202,   82,
+       76,   84,   84,   83,   98,   90,  116,   90,  202,  102,
+      134,  202,  101,  107,  105,    0,  111,    0,  120,  114,
+        0,   55,   49,  121,  123,  126,  124,  142,  144,  132,
+      202,  202,  163,  167,  171,   37,  175,  177,  181,  183,
+      187,  189,  193,  195,  197
 
     } ;
 
-static yyconst flex_int16_t yy_def[92] =
+static yyconst flex_int16_t yy_def[96] =
     {   0,
-       78,    1,   79,   79,    4,    4,   80,   80,   78,   78,
-       78,   78,   78,   81,   78,   78,   13,   78,   13,   78,
-       78,   78,   78,   78,   78,   82,   78,   83,   84,   82,
-       85,   78,   86,   85,   87,   87,   78,   13,   13,   81,
-       78,   78,   78,   78,   78,   78,   78,   78,   82,   82,
-       78,   88,   89,   83,   84,   88,   78,   84,   78,   85,
-       88,   78,   90,   86,   90,   86,   85,   90,   87,   87,
-       89,   91,   89,   89,   91,   91,   91,    0,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-       78
+       82,    1,   83,   83,    4,    4,   84,   84,   82,   82,
+       82,   82,   82,   85,   82,   82,   13,   82,   13,   82,
+       82,   82,   82,   82,   82,   86,   82,   87,   88,   86,
+       89,   82,   90,   89,   91,   91,   82,   13,   13,   85,
+       82,   82,   82,   82,   82,   82,   82,   82,   82,   86,
+       86,   82,   92,   93,   94,   87,   88,   92,   82,   92,
+       88,   82,   89,   92,   82,   95,   90,   95,   90,   89,
+       95,   91,   91,   93,   94,   93,   93,   94,   94,   94,
+       82,    0,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82
 
     } ;
 
-static yyconst flex_int16_t yy_nxt[310] =
+static yyconst flex_int16_t yy_nxt[227] =
     {   0,
-       10,   11,   12,   11,   13,   10,   14,   13,   15,   16,
+       10,   11,   12,   10,   13,   10,   14,   13,   15,   16,
        17,   18,   19,   10,   13,   20,   21,   13,   22,   13,
-       23,   10,   24,   25,   27,   12,   27,   10,   28,   29,
-       32,   34,   32,   34,   36,   33,   33,   37,   10,   37,
-       53,   30,   31,   12,   31,   36,   28,   29,   46,   47,
-       46,   51,   44,   51,   44,   65,   52,   65,   49,   30,
-       38,   70,   37,   38,   37,   70,   38,   38,   39,   38,
-       38,   45,   66,   38,   57,   38,   57,   38,   56,   57,
-       56,   60,   62,   60,   62,   54,   61,   63,   67,   44,
-       67,   44,   65,   68,   65,   58,   46,   47,   46,   46,
-
-       47,   46,   51,   65,   51,   65,   57,   52,   45,   66,
-       60,   50,   60,   50,   72,   61,   72,   62,   73,   62,
-       66,   67,   63,   67,   50,   78,   68,   78,   78,   70,
-       78,   74,   56,   57,   56,   70,   54,   50,   48,   43,
-       42,   41,   74,   78,   78,   77,   78,   78,   78,   58,
-       56,   57,   56,   78,   78,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   58,   72,   78,
-       72,   78,   73,   78,   78,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   74,   72,   78,   72,   78,
-       76,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-
-       78,   78,   78,   77,   72,   78,   72,   78,   73,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-       78,   74,   72,   78,   72,   78,   76,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   77,
-       72,   78,   72,   78,   76,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   77,   26,   26,
-       26,   35,   35,   35,   40,   40,   55,   55,   55,   59,
-       59,   64,   64,   69,   69,   56,   56,   56,   71,   71,
-       65,   65,   75,   75,    9,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-
-       78,   78,   78,   78,   78,   78,   78,   78,   78
+       23,   10,   24,   25,   27,   12,   10,   32,   28,   29,
+       34,   44,   33,   10,   10,   33,   44,   50,   10,   10,
+       36,   30,   31,   12,   10,   36,   28,   29,   55,   52,
+       45,   46,   47,   48,   53,   45,   63,   65,   73,   30,
+       38,   64,   66,   38,   73,   56,   38,   38,   39,   38,
+       38,   70,   68,   38,   68,   38,   71,   38,   58,   59,
+       60,   46,   47,   48,   75,   52,   59,   60,   76,   69,
+       53,   82,   59,   60,   51,   61,   46,   47,   48,   75,
+
+       51,   77,   63,   79,   81,   60,   65,   64,   56,   59,
+       60,   66,   68,   51,   68,   70,   80,   58,   59,   60,
+       71,   68,   75,   68,   75,   82,   76,   75,   79,   69,
+       47,   76,   37,   82,   61,   58,   59,   60,   69,   77,
+       73,   80,   77,   75,   77,   75,   73,   79,   51,   79,
+       80,   49,   61,   43,   42,   41,   37,   82,   82,   82,
+       80,   82,   80,   26,   26,   26,   26,   35,   35,   35,
+       35,   40,   40,   82,   40,   54,   54,   57,   57,   57,
+       57,   62,   62,   67,   67,   82,   67,   72,   72,   58,
+       58,   58,   58,   74,   74,   78,   78,   68,   68,   82,
+
+       68,    9,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82,   82
     } ;
 
-static yyconst flex_int16_t yy_chk[310] =
+static yyconst flex_int16_t yy_chk[227] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    3,    3,    3,    7,    3,    3,
-        5,    6,    5,    6,    7,    5,    6,   11,    8,   11,
-       83,    3,    4,    4,    4,    8,    4,    4,   22,   22,
-       22,   27,   20,   27,   20,   33,   27,   33,   82,    4,
-       13,   70,   37,   13,   37,   69,   13,   13,   13,   13,
-       13,   20,   33,   13,   61,   13,   56,   13,   29,   29,
-       29,   31,   32,   31,   32,   54,   31,   32,   34,   44,
-       34,   44,   64,   34,   64,   29,   30,   30,   30,   46,
-
-       46,   46,   51,   66,   51,   66,   52,   51,   44,   64,
-       60,   50,   60,   30,   53,   60,   53,   62,   53,   62,
-       66,   67,   62,   67,   49,   74,   67,   74,   77,   36,
-       77,   53,   55,   55,   55,   35,   28,   26,   25,   19,
-       18,   17,   74,    9,    0,   77,    0,    0,    0,   55,
-       58,   58,   58,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   58,   71,    0,
-       71,    0,   71,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,   71,   72,    0,   72,    0,
-       72,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-
-        0,    0,    0,   72,   73,    0,   73,    0,   73,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,   73,   75,    0,   75,    0,   75,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   75,
-       76,    0,   76,    0,   76,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   76,   79,   79,
-       79,   80,   80,   80,   81,   81,   84,   84,   84,   85,
-       85,   86,   86,   87,   87,   88,   88,   88,   89,   89,
-       90,   90,   91,   91,   78,   78,   78,   78,   78,   78,
-       78,   78,   78,   78,   78,   78,   78,   78,   78,   78,
-
-       78,   78,   78,   78,   78,   78,   78,   78,   78
+        1,    1,    1,    1,    3,    3,    3,    5,    3,    3,
+        6,   20,    5,    7,    7,    6,   44,   86,    8,    8,
+        7,    3,    4,    4,    4,    8,    4,    4,   28,   27,
+       20,   22,   22,   22,   27,   44,   31,   32,   73,    4,
+       13,   31,   32,   13,   72,   28,   13,   13,   13,   13,
+       13,   34,   33,   13,   33,   13,   34,   13,   29,   29,
+       29,   46,   46,   46,   54,   52,   53,   53,   54,   33,
+       52,   56,   58,   58,   51,   29,   30,   30,   30,   55,
+
+       50,   54,   63,   55,   60,   60,   65,   63,   56,   64,
+       64,   65,   67,   30,   67,   70,   55,   57,   57,   57,
+       70,   69,   74,   69,   75,   77,   74,   76,   75,   67,
+       48,   76,   37,   80,   57,   61,   61,   61,   69,   74,
+       36,   75,   77,   78,   76,   79,   35,   78,   26,   79,
+       80,   25,   61,   19,   18,   17,   11,    9,    0,    0,
+       78,    0,   79,   83,   83,   83,   83,   84,   84,   84,
+       84,   85,   85,    0,   85,   87,   87,   88,   88,   88,
+       88,   89,   89,   90,   90,    0,   90,   91,   91,   92,
+       92,   92,   92,   93,   93,   94,   94,   95,   95,    0,
+
+       95,   82,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
+       82,   82,   82,   82,   82,   82
     } ;
 
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
+/* Table of booleans, true if rule could match eol. */
+static yyconst flex_int32_t yy_rule_can_match_eol[25] =
+    {   0,
+0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 1, 0, 0,     };
 
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
@@ -546,7 +510,6 @@ int yy_flex_debug = 0;
 #define yymore() yymore_used_but_not_detected
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
 #line 1 "qmake.ll"
 #line 2 "qmake.ll"
 /***************************************************************************
@@ -569,9 +532,12 @@ char *yytext;
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
-#include <qmake_yacc.h>
 #include <stdlib.h>
 
+#define DONT_INCLUDE_FLEXLEXER
+
+#include "qmake_lex.h"
+
 /**
 @file qmake.ll
 QMake Lexer
@@ -598,7 +564,7 @@ To debug this lexer, put the line below 
 
 
 
-#line 602 "qmake_lex.cpp"
+#line 568 "qmake_lex.cpp"
 
 #define INITIAL 0
 #define list 1
@@ -617,22 +583,6 @@ To debug this lexer, put the line below 
 #define YY_EXTRA_TYPE void *
 #endif
 
-static int yy_init_globals (void );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap (void );
-#else
-extern int yywrap (void );
-#endif
-#endif
-
-    static void yyunput (int c,char *buf_ptr  );
-    
 #ifndef yytext_ptr
 static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
@@ -643,12 +593,6 @@ static int yy_flex_strlen (yyconst char 
 
 #ifndef YY_NO_INPUT
 
-#ifdef __cplusplus
-static int yyinput (void );
-#else
-static int input (void );
-#endif
-
 #endif
 
 /* Amount of stuff to slurp up with each read. */
@@ -658,10 +602,7 @@ static int input (void );
 
 /* Copy whatever the last rule matched to the standard output. */
 #ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO LexerOutput( yytext, yyleng )
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -669,34 +610,9 @@ static int input (void );
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		size_t n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
 \
+	if ( (result = LexerInput( (char *) buf, max_size )) < 0 ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
 
 #endif
 
@@ -715,7 +631,7 @@ static int input (void );
 
 /* Report a fatal error. */
 #ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#define YY_FATAL_ERROR(msg) LexerError( msg )
 #endif
 
 /* end tables serialization structures and prototypes */
@@ -725,10 +641,7 @@ static int input (void );
  */
 #ifndef YY_DECL
 #define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
+#define YY_DECL int yyFlexLexer::yylex()
 #endif /* !YY_DECL */
 
 /* Code executed at the beginning of each rule, after yytext and yyleng
@@ -757,9 +670,9 @@ YY_DECL
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
     
-#line 72 "qmake.ll"
+#line 78 "qmake.ll"
 
-#line 763 "qmake_lex.cpp"
+#line 676 "qmake_lex.cpp"
 
 	if ( !(yy_init) )
 		{
@@ -773,18 +686,18 @@ YY_DECL
 			(yy_start) = 1;	/* first start state */
 
 		if ( ! yyin )
-			yyin = stdin;
+			yyin = & std::cin;
 
 		if ( ! yyout )
-			yyout = stdout;
+			yyout = & std::cout;
 
 		if ( ! YY_CURRENT_BUFFER ) {
 			yyensure_buffer_stack ();
 			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
+				yy_create_buffer( yyin, YY_BUF_SIZE );
 		}
 
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 		}
 
 	while ( 1 )		/* loops until end-of-file is reached */
@@ -813,13 +726,13 @@ yy_match:
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 79 )
+				if ( yy_current_state >= 83 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_base[yy_current_state] != 285 );
+		while ( yy_base[yy_current_state] != 202 );
 
 yy_find_action:
 		yy_act = yy_accept[yy_current_state];
@@ -832,6 +745,16 @@ yy_find_action:
 
 		YY_DO_BEFORE_ACTION;
 
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			int yyl;
+			for ( yyl = 0; yyl < yyleng; ++yyl )
+				if ( yytext[yyl] == '\n' )
+					   
+    yylineno++;
+;
+			}
+
 do_action:	/* This label is used only to access EOF actions. */
 
 		switch ( yy_act )
@@ -845,147 +768,205 @@ do_action:	/* This label is used only to
 
 case 1:
 YY_RULE_SETUP
-#line 73 "qmake.ll"
+#line 79 "qmake.ll"
 {}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 74 "qmake.ll"
-{ yylval.value = yytext; return LIST_WS; }
+#line 81 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::LIST_WS;
+}
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 75 "qmake.ll"
-{ 
-    yylval.value = yytext;
-    unput(char(yylval.value.at(yylval.value.length()-1).latin1()));
-    yylval.value = yylval.value.mid(0, yylval.value.length()-1);
-    return INDENT;
+#line 86 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    unput(char(mylval->value.at(mylval->value.length()-1).latin1()));
+    mylval->value = mylval->value.mid(0, mylval->value.length()-1);
+    return Parser::token::token::INDENT;
 }
 	YY_BREAK
 case 4:
 /* rule 4 can match eol */
 YY_RULE_SETUP
-#line 82 "qmake.ll"
-{ BEGIN(list); return CONT; }
+#line 93 "qmake.ll"
+{
+    BEGIN(list);
+    return Parser::token::token::CONT;
+}
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 83 "qmake.ll"
-{ yylval.value = yytext; return (ID_SIMPLE); }
+#line 97 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return (Parser::token::token::ID_SIMPLE);
+}
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 85 "qmake.ll"
+#line 102 "qmake.ll"
 {
-    yylval.value = yytext;
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
     BEGIN(list);
-    return (LIST_COMMENT_WITHOUT_NEWLINE);
+    return (Parser::token::token::LIST_COMMENT_WITHOUT_NEWLINE);
 }
 	YY_BREAK
 case 7:
 /* rule 7 can match eol */
 YY_RULE_SETUP
-#line 91 "qmake.ll"
+#line 108 "qmake.ll"
 {
-    yylval.value = yytext;
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
     BEGIN(list);
-    return (LIST_COMMENT);
+    return (Parser::token::token::LIST_COMMENT);
     }
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 97 "qmake.ll"
+#line 114 "qmake.ll"
 {
-    yylval.value = yytext;
-    yylval.value = yylval.value.mid(0, yylval.value.length()-1);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    mylval->value = mylval->value.mid(0, mylval->value.length()-1);
     unput(')');
     BEGIN(INITIAL);
-    return (ID_ARGS);
+    return (Parser::token::token::ID_ARGS);
     }
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 105 "qmake.ll"
-{ BEGIN(list_with_comment); yylval.value = yytext; return VARIABLE_VALUE; }
+#line 122 "qmake.ll"
+{
+    BEGIN(list_with_comment);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::VARIABLE_VALUE;
+}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 106 "qmake.ll"
-{ BEGIN(list_with_comment); yylval.value = yytext; return QUOTED_VARIABLE_VALUE; }
+#line 128 "qmake.ll"
+{
+    BEGIN(list_with_comment);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::QUOTED_VARIABLE_VALUE;
+}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 108 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return EQ; }
+#line 134 "qmake.ll"
+{
+BEGIN(list);
+mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+return Parser::token::token::EQ;
+}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 109 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return PLUSEQ; }
+#line 140 "qmake.ll"
+{
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::PLUSEQ;
+}
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 110 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return MINUSQE; }
+#line 146 "qmake.ll"
+{
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::MINUSEQ;
+}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 111 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return STAREQ; }
+#line 152 "qmake.ll"
+{
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::STAREQ;
+}
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 112 "qmake.ll"
-{ BEGIN(list); yylval.value = yytext; return TILDEEQ; }
+#line 158 "qmake.ll"
+{
+    BEGIN(list);
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::TILDEEQ;
+}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 113 "qmake.ll"
-{ return LCURLY; }
+#line 164 "qmake.ll"
+{
+    return Parser::token::token::LCURLY;
+}
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 114 "qmake.ll"
-{ return LCURLY; }
+#line 168 "qmake.ll"
+{
+    return Parser::token::token::LCURLY;
+}
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 115 "qmake.ll"
-{ return RCURLY; }
+#line 172 "qmake.ll"
+{
+    return Parser::token::token::RCURLY;
+}
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 116 "qmake.ll"
-{ BEGIN(funcargs); return LBRACE; }
+#line 176 "qmake.ll"
+{
+    BEGIN(funcargs);
+    return Parser::token::token::LBRACE;
+}
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 117 "qmake.ll"
-{ BEGIN(INITIAL); return RBRACE; }
+#line 181 "qmake.ll"
+{
+    BEGIN(INITIAL);
+    return Parser::token::token::RBRACE;
+}
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 118 "qmake.ll"
-{ yylval.value = yytext; return COLON; }
+#line 186 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return Parser::token::token::COLON;
+}
 	YY_BREAK
 case 22:
 /* rule 22 can match eol */
 YY_RULE_SETUP
-#line 119 "qmake.ll"
-{ BEGIN(INITIAL); return NEWLINE; }
+#line 191 "qmake.ll"
+{
+    BEGIN(INITIAL);
+    return Parser::token::token::NEWLINE;
+}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 121 "qmake.ll"
-{ yylval.value = yytext; return (COMMENT); }
+#line 196 "qmake.ll"
+{
+    mylval->value = QString::fromLocal8Bit( YYText(), YYLeng() );
+    return (Parser::token::token::COMMENT);
+}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 123 "qmake.ll"
+#line 201 "qmake.ll"
 ECHO;
 	YY_BREAK
-#line 989 "qmake_lex.cpp"
+#line 970 "qmake_lex.cpp"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(list):
 case YY_STATE_EOF(list_with_comment):
@@ -1066,7 +1047,7 @@ case YY_STATE_EOF(funcargs):
 				{
 				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap( ) )
+				if ( yywrap(  ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
@@ -1121,6 +1102,81 @@ case YY_STATE_EOF(funcargs):
 		} /* end of scanning one token */
 } /* end of yylex */
 
+yyFlexLexer::yyFlexLexer( std::istream* arg_yyin, std::ostream* arg_yyout )
+{
+	yyin = arg_yyin;
+	yyout = arg_yyout;
+	yy_c_buf_p = 0;
+	yy_init = 0;
+	yy_start = 0;
+	yy_flex_debug = 0;
+	yylineno = 1;	// this will only get updated if %option yylineno
+
+	yy_did_buffer_switch_on_eof = 0;
+
+	yy_looking_for_trail_begin = 0;
+	yy_more_flag = 0;
+	yy_more_len = 0;
+	yy_more_offset = yy_prev_more_offset = 0;
+
+	yy_start_stack_ptr = yy_start_stack_depth = 0;
+	yy_start_stack = NULL;
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+
+	yy_state_buf = 0;
+
+}
+
+void yyFlexLexer::switch_streams( std::istream* new_in, std::ostream* new_out )
+{
+	if ( new_in )
+		{
+		yy_delete_buffer( YY_CURRENT_BUFFER );
+		yy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE  ) );
+		}
+
+	if ( new_out )
+		yyout = new_out;
+}
+
+#ifdef YY_INTERACTIVE
+int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )
+#else
+int yyFlexLexer::LexerInput( char* buf, int max_size )
+#endif
+{
+	if ( yyin->eof() || yyin->fail() )
+		return 0;
+
+#ifdef YY_INTERACTIVE
+	yyin->get( buf[0] );
+
+	if ( yyin->eof() )
+		return 0;
+
+	if ( yyin->bad() )
+		return -1;
+
+	return 1;
+
+#else
+	(void) yyin->read( buf, max_size );
+
+	if ( yyin->bad() )
+		return -1;
+	else
+		return yyin->gcount();
+#endif
+}
+
+void yyFlexLexer::LexerOutput( const char* buf, int size )
+{
+	(void) yyout->write( buf, size );
+}
+
 /* yy_get_next_buffer - try to read in a new buffer
  *
  * Returns a code representing an action:
@@ -1128,7 +1184,7 @@ case YY_STATE_EOF(funcargs):
  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  *	EOB_ACT_END_OF_FILE - end of file
  */
-static int yy_get_next_buffer (void)
+int yyFlexLexer::yy_get_next_buffer()
 {
     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
 	register char *source = (yytext_ptr);
@@ -1229,7 +1285,7 @@ static int yy_get_next_buffer (void)
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
+			yyrestart( yyin  );
 			}
 
 		else
@@ -1254,7 +1310,7 @@ static int yy_get_next_buffer (void)
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-    static yy_state_type yy_get_previous_state (void)
+    yy_state_type yyFlexLexer::yy_get_previous_state()
 {
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
@@ -1273,7 +1329,7 @@ static int yy_get_next_buffer (void)
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 79 )
+			if ( yy_current_state >= 83 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
@@ -1287,7 +1343,7 @@ static int yy_get_next_buffer (void)
  * synopsis
  *	next_state = yy_try_NUL_trans( current_state );
  */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+    yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )
 {
 	register int yy_is_jam;
     	register char *yy_cp = (yy_c_buf_p);
@@ -1301,16 +1357,16 @@ static int yy_get_next_buffer (void)
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 79 )
+		if ( yy_current_state >= 83 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 78);
+	yy_is_jam = (yy_current_state == 82);
 
 	return yy_is_jam ? 0 : yy_current_state;
 }
 
-    static void yyunput (int c, register char * yy_bp )
+    void yyFlexLexer::yyunput( int c, register char* yy_bp)
 {
 	register char *yy_cp;
     
@@ -1342,18 +1398,16 @@ static int yy_get_next_buffer (void)
 
 	*--yy_cp = (char) c;
 
+    if ( c == '\n' ){
+        --yylineno;
+    }
+
 	(yytext_ptr) = yy_bp;
 	(yy_hold_char) = *yy_cp;
 	(yy_c_buf_p) = yy_cp;
 }
 
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
+    int yyFlexLexer::yyinput()
 {
 	int c;
     
@@ -1388,13 +1442,13 @@ static int yy_get_next_buffer (void)
 					 */
 
 					/* Reset buffer status. */
-					yyrestart(yyin );
+					yyrestart( yyin );
 
 					/*FALLTHROUGH*/
 
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap( ) )
+					if ( yywrap(  ) )
 						return EOF;
 
 					if ( ! (yy_did_buffer_switch_on_eof) )
@@ -1418,34 +1472,37 @@ static int yy_get_next_buffer (void)
 	(yy_hold_char) = *++(yy_c_buf_p);
 
 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_at_bol )
+		   
+    yylineno++;
+;
 
 	return c;
 }
-#endif	/* ifndef YY_NO_INPUT */
 
 /** Immediately switch to a different input stream.
  * @param input_file A readable stream.
  * 
  * @note This function does not reset the start condition to @c INITIAL .
  */
-    void yyrestart  (FILE * input_file )
+    void yyFlexLexer::yyrestart( std::istream* input_file )
 {
     
 	if ( ! YY_CURRENT_BUFFER ){
         yyensure_buffer_stack ();
 		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
+            yy_create_buffer( yyin, YY_BUF_SIZE );
 	}
 
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
+	yy_load_buffer_state(  );
 }
 
 /** Switch to a different input buffer.
  * @param new_buffer The new input buffer.
  * 
  */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+    void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
 {
     
 	/* TODO. We should be able to replace this entire function body
@@ -1466,7 +1523,7 @@ static int yy_get_next_buffer (void)
 		}
 
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
+	yy_load_buffer_state(  );
 
 	/* We don't actually know whether we did this switch during
 	 * EOF (yywrap()) processing, but the only time this flag
@@ -1476,7 +1533,7 @@ static int yy_get_next_buffer (void)
 	(yy_did_buffer_switch_on_eof) = 1;
 }
 
-static void yy_load_buffer_state  (void)
+    void yyFlexLexer::yy_load_buffer_state()
 {
     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
@@ -1490,7 +1547,7 @@ static void yy_load_buffer_state  (void)
  * 
  * @return the allocated buffer state.
  */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+    YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream* file, int size )
 {
 	YY_BUFFER_STATE b;
     
@@ -1509,7 +1566,7 @@ static void yy_load_buffer_state  (void)
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer(b,file );
+	yy_init_buffer( b, file );
 
 	return b;
 }
@@ -1518,7 +1575,7 @@ static void yy_load_buffer_state  (void)
  * @param b a buffer created with yy_create_buffer()
  * 
  */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
+    void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )
 {
     
 	if ( ! b )
@@ -1533,20 +1590,18 @@ static void yy_load_buffer_state  (void)
 	yyfree((void *) b  );
 }
 
-#ifndef __cplusplus
-extern int isatty (int );
-#endif /* __cplusplus */
-    
+extern "C" int isatty (int );
+
 /* Initializes or reinitializes a buffer.
  * This function is sometimes called more than once on the same buffer,
  * such as during a yyrestart() or at EOF.
  */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+    void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, std::istream* file )
 
 {
 	int oerrno = errno;
     
-	yy_flush_buffer(b );
+	yy_flush_buffer( b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
@@ -1560,8 +1615,7 @@ extern int isatty (int );
         b->yy_bs_column = 0;
     }
 
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
+	b->yy_is_interactive = 0;
 	errno = oerrno;
 }
 
@@ -1569,7 +1623,7 @@ extern int isatty (int );
  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
  * 
  */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
+    void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )
 {
     	if ( ! b )
 		return;
@@ -1589,7 +1643,7 @@ extern int isatty (int );
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
 	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 }
 
 /** Pushes the new state onto the stack. The new state becomes
@@ -1598,7 +1652,7 @@ extern int isatty (int );
  *  @param new_buffer The new state.
  *  
  */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+void yyFlexLexer::yypush_buffer_state (YY_BUFFER_STATE new_buffer)
 {
     	if (new_buffer == NULL)
 		return;
@@ -1620,7 +1674,7 @@ void yypush_buffer_state (YY_BUFFER_STAT
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
 
 	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
+	yy_load_buffer_state(  );
 	(yy_did_buffer_switch_on_eof) = 1;
 }
 
@@ -1628,7 +1682,7 @@ void yypush_buffer_state (YY_BUFFER_STAT
  *  The next element becomes the new top.
  *  
  */
-void yypop_buffer_state (void)
+void yyFlexLexer::yypop_buffer_state (void)
 {
     	if (!YY_CURRENT_BUFFER)
 		return;
@@ -1639,7 +1693,7 @@ void yypop_buffer_state (void)
 		--(yy_buffer_stack_top);
 
 	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
+		yy_load_buffer_state(  );
 		(yy_did_buffer_switch_on_eof) = 1;
 	}
 }
@@ -1647,7 +1701,7 @@ void yypop_buffer_state (void)
 /* Allocates the stack if it does not exist.
  *  Guarantees space for at least one push.
  */
-static void yyensure_buffer_stack (void)
+void yyFlexLexer::yyensure_buffer_stack(void)
 {
 	int num_to_alloc;
     
@@ -1686,99 +1740,51 @@ static void yyensure_buffer_stack (void)
 	}
 }
 
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object. 
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+    void yyFlexLexer::yy_push_state( int new_state )
 {
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
+    	if ( (yy_start_stack_ptr) >= (yy_start_stack_depth) )
+		{
+		yy_size_t new_size;
 
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+		(yy_start_stack_depth) += YY_START_STACK_INCR;
+		new_size = (yy_start_stack_depth) * sizeof( int );
 
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
+		if ( ! (yy_start_stack) )
+			(yy_start_stack) = (int *) yyalloc(new_size  );
 
-	yy_switch_to_buffer(b  );
+		else
+			(yy_start_stack) = (int *) yyrealloc((void *) (yy_start_stack),new_size  );
 
-	return b;
-}
+		if ( ! (yy_start_stack) )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
 
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
-{
-    
-	return yy_scan_bytes(yystr,strlen(yystr) );
+	(yy_start_stack)[(yy_start_stack_ptr)++] = YY_START;
+
+	BEGIN(new_state);
 }
 
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+    void yyFlexLexer::yy_pop_state()
 {
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
-	buf = (char *) yyalloc(n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
+    	if ( --(yy_start_stack_ptr) < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
 
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer(buf,n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
+	BEGIN((yy_start_stack)[(yy_start_stack_ptr)]);
+}
 
-	return b;
+    int yyFlexLexer::yy_top_state()
+{
+    	return (yy_start_stack)[(yy_start_stack_ptr) - 1];
 }
 
 #ifndef YY_EXIT_FAILURE
 #define YY_EXIT_FAILURE 2
 #endif
 
-static void yy_fatal_error (yyconst char* msg )
+void yyFlexLexer::LexerError( yyconst char msg[] )
 {
-    	(void) fprintf( stderr, "%s\n", msg );
+    	std::cerr << msg << std::endl;
 	exit( YY_EXIT_FAILURE );
 }
 
@@ -1801,119 +1807,12 @@ static void yy_fatal_error (yyconst char
 
 /* Accessor  methods (get/set functions) to struct members. */
 
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-        
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-int yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param line_number
- * 
- */
-void yyset_lineno (int  line_number )
-{
-    
-    yylineno = line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  in_str )
-{
-        yyin = in_str ;
-}
-
-void yyset_out (FILE *  out_str )
-{
-        yyout = out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  bdebug )
-{
-        yy_flex_debug = bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = 0;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = (char *) 0;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
+yyFlexLexer::~yyFlexLexer()
 {
     
     /* Pop the buffer stack, destroying each element. */
 	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		yy_delete_buffer( YY_CURRENT_BUFFER  );
 		YY_CURRENT_BUFFER_LVALUE = NULL;
 		yypop_buffer_state();
 	}
@@ -1922,11 +1821,9 @@ int yylex_destroy  (void)
 	yyfree((yy_buffer_stack) );
 	(yy_buffer_stack) = NULL;
 
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
+	delete [] (yy_state_buf);
+	yyfree((yy_start_stack)  );
 
-    return 0;
 }
 
 /*
@@ -1977,7 +1874,26 @@ void yyfree (void * ptr )
 
 #define YYTABLES_NAME "yytables"
 
-#line 123 "qmake.ll"
+#line 201 "qmake.ll"
 
 
+namespace QMake
+{
+    Lexer::Lexer( std::istream* argin, std::ostream* argout )
+        : yyFlexLexer(argin, argout), mylval(0)
+    {
+    }
+
+    int Lexer::yylex( QMake::Parser::semantic_type* yylval )
+    {
+        mylval = yylval;
+        return yylex();
+    }
+}
+
+int QMakelex( QMake::Parser::semantic_type* yylval, QMake::Lexer* lexer)
+{
+    return lexer->yylex( yylval );
+}
+
 
