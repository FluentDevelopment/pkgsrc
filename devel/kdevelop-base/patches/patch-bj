$NetBSD: patch-bj,v 1.1 2007/03/24 14:01:31 markd Exp $

--- buildtools/lib/parsers/qmake/qmake_yacc.cpp.orig	2007-01-26 04:42:02.000000000 +1300
+++ buildtools/lib/parsers/qmake/qmake_yacc.cpp
@@ -1,9 +1,8 @@
 /* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton implementation for Bison's Yacc-like parsers in C
+/* Skeleton implementation for Bison LALR(1) parsers in C++
 
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -33,1476 +32,363 @@
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
-/* C LALR(1) parser skeleton written by Richard Stallman, by
-   simplifying the original so-called "semantic" parser.  */
+// Take the name prefix into account.
+#define yylex   QMakelex
 
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Bison version.  */
-#define YYBISON_VERSION "2.3"
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
+#include "qmake_yacc.hpp"
 
+/* User implementation prologue.  */
 
 
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     ID_SIMPLE = 258,
-     EQ = 259,
-     PLUSEQ = 260,
-     MINUSQE = 261,
-     STAREQ = 262,
-     TILDEEQ = 263,
-     LBRACE = 264,
-     RBRACE = 265,
-     COLON = 266,
-     NUMSIGN = 267,
-     NEWLINE = 268,
-     NUMBER = 269,
-     COMMENT = 270,
-     CONT = 271,
-     RCURLY = 272,
-     LCURLY = 273,
-     ID_ARGS = 274,
-     LIST_COMMENT = 275,
-     LIST_COMMENT_WITHOUT_NEWLINE = 276,
-     QUOTED_VARIABLE_VALUE = 277,
-     VARIABLE_VALUE = 278,
-     INDENT = 279,
-     LIST_WS = 280
-   };
-#endif
-/* Tokens.  */
-#define ID_SIMPLE 258
-#define EQ 259
-#define PLUSEQ 260
-#define MINUSQE 261
-#define STAREQ 262
-#define TILDEEQ 263
-#define LBRACE 264
-#define RBRACE 265
-#define COLON 266
-#define NUMSIGN 267
-#define NEWLINE 268
-#define NUMBER 269
-#define COMMENT 270
-#define CONT 271
-#define RCURLY 272
-#define LCURLY 273
-#define ID_ARGS 274
-#define LIST_COMMENT 275
-#define LIST_COMMENT_WITHOUT_NEWLINE 276
-#define QUOTED_VARIABLE_VALUE 277
-#define VARIABLE_VALUE 278
-#define INDENT 279
-#define LIST_WS 280
-
-
-
-
-/* Copy the first part of user declarations.  */
-#line 1 "qmake.yy"
-
-/***************************************************************************
- *   Copyright (C) 2005 by Alexander Dymo                                  *
- *   adymo@kdevelop.org                                                    *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU Library General Public License as       *
- *   published by the Free Software Foundation; either version 2 of the    *
- *   License, or (at your option) any later version.                       *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU Library General Public     *
- *   License along with this program; if not, write to the                 *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-/**
-@file qmake.yy
-QMake Parser
-
-Simple LALR parser which builds the syntax tree (see @ref QMake::AST).
-
-@todo Recognize comments after statements like:
-SOURCES = foo #regognize me
-
-@fixme Parser fails on files that do not end with a newline
-@fixme 1 shift/reduce conflict in "line_body" rule
-*/
-
-#include <qvaluestack.h>
-#include "qmakeast.h"
-#include <qregexp.h>
-
-#define YYSTYPE_IS_DECLARED
-
-using namespace QMake;
-
-/**
-The yylval type.
-*/
-struct Result {
-    Result(): node(0) {}
-
-    /**Type of semantic value for simple grammar rules.*/
-    QString value;
-    /**Type of semantic value for grammar rules which are parts of AST.*/
-    AST *node;
-    /**Type of semantic value for "multiline_values" grammar rule.
-    Each line of multiline value is stored as a string in the list.
-
-    For example we have in .pro file:
-    @code
-    SOURCE = foo1.cpp \
-        foo2.cpp \
-        foo3.cpp foo4.cpp
-    @endcode
-    The string list will be populated with three strings:
-    <pre>
-    foo1.cpp
-    foo2.cpp
-    foo3.cpp foo4.cpp
-    </pre>
-    */
-    QStringList values;
-    QString indent;
-};
-
-typedef Result YYSTYPE;
-
-void yyerror(const char *str) {
-    printf("%s\n", str);
-}
-
-int yylex();
-
-/**
-The stack to store ProjectAST pointers when a new child
-ProjectAST is created and filled with statements.
-
-Parser creates root ProjectAST for a .pro file, pushes it onto the stack and starts
-adding statements. Each statement is added as a child StatementAST to the ProjectAST
-currently on the top in the stack.
-
-When a scope or function scope statement is parsed, the child ProjectAST is created
-and pushed onto the stack. Therefore all statements which belong to the scope
-or function scope are added as childs to their direct parent (scope or function scope).
-*/
-QValueStack<ProjectAST*> projects;
-
-/**
-The current depth of AST node is stored here.
-AST depth is important to know because automatic indentation can
-be easily implemented (the parser itself looses all information
-about indentation).
-*/
-int depth = 0;
-
-/*
-To debug this parser, put the line below into the next bison file section.
-Don't forget to uncomment "yydebug = 1" line in qmakedriver.cpp.
-%debug
-*/
-
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef int YYSTYPE;
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-# define YYSTYPE_IS_TRIVIAL 1
-#endif
-
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 216 of yacc.c.  */
-#line 265 "qmake_yacc.cpp"
-
-#ifdef short
-# undef short
-#endif
-
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
-#endif
-
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
-#elif (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-typedef signed char yytype_int8;
-#else
-typedef short int yytype_int8;
-#endif
-
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
-#else
-typedef unsigned short int yytype_uint16;
-#endif
-
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
-#else
-typedef short int yytype_int16;
-#endif
-
-#ifndef YYSIZE_T
-# ifdef __SIZE_TYPE__
-#  define YYSIZE_T __SIZE_TYPE__
-# elif defined size_t
-#  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# else
-#  define YYSIZE_T unsigned int
-# endif
-#endif
-
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+/* Line 317 of lalr1.cc.  */
+#line 45 "qmake_yacc.cpp"
 
 #ifndef YY_
 # if YYENABLE_NLS
 #  if ENABLE_NLS
-#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   include <libintl.h> /* FIXME: INFRINGES ON USER NAME SPACE */
 #   define YY_(msgid) dgettext ("bison-runtime", msgid)
 #  endif
 # endif
 # ifndef YY_
 #  define YY_(msgid) msgid
 # endif
-#endif
-
-/* Suppress unused-variable warnings by "using" E.  */
-#if ! defined lint || defined __GNUC__
-# define YYUSE(e) ((void) (e))
-#else
-# define YYUSE(e) /* empty */
-#endif
-
-/* Identity function, used to suppress warnings about constant conditions.  */
-#ifndef lint
-# define YYID(n) (n)
-#else
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static int
-YYID (int i)
-#else
-static int
-YYID (i)
-    int i;
-#endif
-{
-  return i;
-}
-#endif
-
-#if ! defined yyoverflow || YYERROR_VERBOSE
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   elif defined __BUILTIN_VA_ARG_INCR
-#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
-#   elif defined _AIX
-#    define YYSTACK_ALLOC __alloca
-#   elif defined _MSC_VER
-#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
-#    define alloca _alloca
-#   else
-#    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef _STDLIB_H
-#      define _STDLIB_H 1
-#     endif
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning.  */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-    /* The OS might guarantee only one guard page at the bottom of the stack,
-       and a page size can be as small as 4096 bytes.  So we cannot safely
-       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
-       to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
-#  endif
-# else
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
-#  endif
-#  if (defined __cplusplus && ! defined _STDLIB_H \
-       && ! ((defined YYMALLOC || defined malloc) \
-	     && (defined YYFREE || defined free)))
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef _STDLIB_H
-#    define _STDLIB_H 1
-#   endif
-#  endif
-#  ifndef YYMALLOC
-#   define YYMALLOC malloc
-#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifndef YYFREE
-#   define YYFREE free
-#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-void free (void *); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-# endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
-
-#if (! defined yyoverflow \
-     && (! defined __cplusplus \
-	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  yytype_int16 yyss;
-  YYSTYPE yyvs;
-  };
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
-      + YYSTACK_GAP_MAXIMUM)
-
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  YYSIZE_T yyi;				\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (YYID (0))
-#  endif
-# endif
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
-
-#endif
-
-/* YYFINAL -- State number of the termination state.  */
-#define YYFINAL  3
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   37
-
-/* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  27
-/* YYNNTS -- Number of nonterminals.  */
-#define YYNNTS  21
-/* YYNRULES -- Number of rules.  */
-#define YYNRULES  44
-/* YYNRULES -- Number of states.  */
-#define YYNSTATES  54
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   281
-
-#define YYTRANSLATE(YYX)						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const yytype_uint8 yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const yytype_uint8 yyprhs[] =
-{
-       0,     0,     3,     4,     7,    10,    11,    13,    15,    17,
-      19,    21,    25,    29,    30,    33,    35,    37,    39,    41,
-      43,    45,    47,    49,    50,    52,    54,    56,    58,    60,
-      62,    64,    65,    69,    70,    78,    80,    81,    85,    88,
-      89,    90,    96,    97,   100
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
-static const yytype_int8 yyrhs[] =
-{
-      28,     0,    -1,    -1,    29,    30,    -1,    30,    31,    -1,
-      -1,    32,    -1,    38,    -1,    40,    -1,    46,    -1,    47,
-      -1,     3,    37,    33,    -1,    33,    34,    35,    -1,    -1,
-      34,    36,    -1,    36,    -1,    16,    -1,    13,    -1,    25,
-      -1,    24,    -1,    20,    -1,    10,    -1,    21,    -1,    -1,
-      23,    -1,    22,    -1,     4,    -1,     5,    -1,     6,    -1,
-       7,    -1,     8,    -1,    -1,     3,    39,    43,    -1,    -1,
-       3,     9,    42,    10,    41,    43,    44,    -1,    19,    -1,
-      -1,    18,    30,    17,    -1,    11,    31,    -1,    -1,    -1,
-      26,    18,    45,    43,    17,    -1,    -1,    15,    13,    -1,
-      13,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const yytype_uint16 yyrline[] =
-{
-       0,   136,   136,   136,   143,   148,   151,   155,   159,   163,
-     167,   173,   185,   193,   200,   201,   202,   203,   204,   205,
-     211,   212,   215,   222,   227,   228,   231,   231,   231,   231,
-     231,   235,   234,   249,   248,   273,   274,   277,   278,   283,
-     287,   286,   300,   305,   313
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
-/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "ID_SIMPLE", "EQ", "PLUSEQ", "MINUSQE",
-  "STAREQ", "TILDEEQ", "LBRACE", "RBRACE", "COLON", "NUMSIGN", "NEWLINE",
-  "NUMBER", "COMMENT", "CONT", "RCURLY", "LCURLY", "ID_ARGS",
-  "LIST_COMMENT", "LIST_COMMENT_WITHOUT_NEWLINE", "QUOTED_VARIABLE_VALUE",
-  "VARIABLE_VALUE", "INDENT", "LIST_WS", "\"else\"", "$accept", "project",
-  "@1", "statements", "statement", "variable_assignment",
-  "multiline_values", "line_body", "opt_comment", "variable_value",
-  "operator", "scope", "@2", "function_call", "@3", "function_args",
-  "scope_body", "else_statement", "@4", "comment", "emptyline", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const yytype_uint16 yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
-{
-       0,    27,    29,    28,    30,    30,    31,    31,    31,    31,
-      31,    32,    33,    33,    34,    34,    34,    34,    34,    34,
-      34,    34,    35,    35,    36,    36,    37,    37,    37,    37,
-      37,    39,    38,    41,    40,    42,    42,    43,    43,    43,
-      45,    44,    44,    46,    47
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
-{
-       0,     2,     0,     2,     2,     0,     1,     1,     1,     1,
-       1,     3,     3,     0,     2,     1,     1,     1,     1,     1,
-       1,     1,     1,     0,     1,     1,     1,     1,     1,     1,
-       1,     0,     3,     0,     7,     1,     0,     3,     2,     0,
-       0,     5,     0,     2,     1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const yytype_uint8 yydefact[] =
-{
-       2,     0,     5,     1,     3,    31,    44,     0,     4,     6,
-       7,     8,     9,    10,    26,    27,    28,    29,    30,    36,
-      13,    39,    43,    35,     0,    11,     0,     5,    32,    33,
-      21,    17,    16,    20,    25,    24,    19,    18,    23,    15,
-      38,     0,    39,    22,    12,    14,    37,    42,     0,    34,
-      40,    39,     0,    41
-};
-
-/* YYDEFGOTO[NTERM-NUM].  */
-static const yytype_int8 yydefgoto[] =
-{
-      -1,     1,     2,     4,     8,     9,    25,    38,    44,    39,
-      20,    10,    21,    11,    42,    24,    28,    49,    51,    12,
-      13
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -41
-static const yytype_int8 yypact[] =
-{
-     -41,     1,   -41,   -41,     5,    18,   -41,    -9,   -41,   -41,
-     -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,   -14,
-     -41,    -2,   -41,   -41,    21,   -10,     5,   -41,   -41,   -41,
-     -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,     7,   -41,
-     -41,     4,    -2,   -41,   -41,   -41,   -41,     6,    15,   -41,
-     -41,    -2,    17,   -41
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yytype_int8 yypgoto[] =
-{
-     -41,   -41,   -41,     8,    10,   -41,   -41,   -41,   -41,    -1,
-     -41,   -41,   -41,   -41,   -41,   -41,   -40,   -41,   -41,   -41,
-     -41
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -1
-static const yytype_uint8 yytable[] =
-{
-      30,     3,    47,    31,    22,    23,    32,     5,     5,    26,
-      33,    52,    34,    35,    36,    37,    27,     6,     6,     7,
-       7,    46,    14,    15,    16,    17,    18,    19,    43,    34,
-      35,    29,    48,    50,    53,    41,    40,    45
-};
-
-static const yytype_uint8 yycheck[] =
-{
-      10,     0,    42,    13,    13,    19,    16,     3,     3,    11,
-      20,    51,    22,    23,    24,    25,    18,    13,    13,    15,
-      15,    17,     4,     5,     6,     7,     8,     9,    21,    22,
-      23,    10,    26,    18,    17,    27,    26,    38
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
-{
-       0,    28,    29,     0,    30,     3,    13,    15,    31,    32,
-      38,    40,    46,    47,     4,     5,     6,     7,     8,     9,
-      37,    39,    13,    19,    42,    33,    11,    18,    43,    10,
-      10,    13,    16,    20,    22,    23,    24,    25,    34,    36,
-      31,    30,    41,    21,    35,    36,    17,    43,    26,    44,
-      18,    45,    43,    17
-};
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-
-#define YYFAIL		goto yyerrlab
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK (1);						\
-      goto yybackup;						\
-    }								\
-  else								\
-    {								\
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;							\
-    }								\
-while (YYID (0))
-
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-
-/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
-   If N is 0, then set CURRENT to the empty location which ends
-   the previous symbol: RHS[0] (always defined).  */
-
-#define YYRHSLOC(Rhs, K) ((Rhs)[K])
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)				\
-    do									\
-      if (YYID (N))                                                    \
-	{								\
-	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
-	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
-	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
-	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
-	}								\
-      else								\
-	{								\
-	  (Current).first_line   = (Current).last_line   =		\
-	    YYRHSLOC (Rhs, 0).last_line;				\
-	  (Current).first_column = (Current).last_column =		\
-	    YYRHSLOC (Rhs, 0).last_column;				\
-	}								\
-    while (YYID (0))
-#endif
-
-
-/* YY_LOCATION_PRINT -- Print the location on the stream.
-   This macro was not mandated originally: define only if we know
-   we won't break user code: when these are the locations we know.  */
-
-#ifndef YY_LOCATION_PRINT
-# if YYLTYPE_IS_TRIVIAL
-#  define YY_LOCATION_PRINT(File, Loc)			\
-     fprintf (File, "%d.%d-%d.%d",			\
-	      (Loc).first_line, (Loc).first_column,	\
-	      (Loc).last_line,  (Loc).last_column)
-# else
-#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-# endif
-#endif
-
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (YYID (0))
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
-do {									  \
-  if (yydebug)								  \
-    {									  \
-      YYFPRINTF (stderr, "%s ", Title);					  \
-      yy_symbol_print (stderr,						  \
-		  Type, Value); \
-      YYFPRINTF (stderr, "\n");						  \
-    }									  \
-} while (YYID (0))
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_value_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (!yyvaluep)
-    return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# else
-  YYUSE (yyoutput);
-# endif
-  switch (yytype)
-    {
-      default:
-	break;
-    }
-}
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (yytype < YYNTOKENS)
-    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
-}
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
-#else
-static void
-yy_stack_print (bottom, top)
-    yytype_int16 *bottom;
-    yytype_int16 *top;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (; bottom <= top; ++bottom)
-    YYFPRINTF (stderr, " %d", *bottom);
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (YYID (0))
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
-#else
-static void
-yy_reduce_print (yyvsp, yyrule)
-    YYSTYPE *yyvsp;
-    int yyrule;
-#endif
-{
-  int yynrhs = yyr2[yyrule];
-  int yyi;
-  unsigned long int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-	     yyrule - 1, yylno);
-  /* The symbols being reduced.  */
-  for (yyi = 0; yyi < yynrhs; yyi++)
-    {
-      fprintf (stderr, "   $%d = ", yyi + 1);
-      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
-		       &(yyvsp[(yyi + 1) - (yynrhs)])
-		       		       );
-      fprintf (stderr, "\n");
-    }
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (yyvsp, Rule); \
-} while (YYID (0))
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static YYSIZE_T
-yystrlen (const char *yystr)
-#else
-static YYSIZE_T
-yystrlen (yystr)
-    const char *yystr;
-#endif
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-#else
-static char *
-yystpcpy (yydest, yysrc)
-    char *yydest;
-    const char *yysrc;
-#endif
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-	switch (*++yyp)
-	  {
-	  case '\'':
-	  case ',':
-	    goto do_not_strip_quotes;
-
-	  case '\\':
-	    if (*++yyp != '\\')
-	      goto do_not_strip_quotes;
-	    /* Fall through.  */
-	  default:
-	    if (yyres)
-	      yyres[yyn] = *yyp;
-	    yyn++;
-	    break;
-
-	  case '"':
-	    if (yyres)
-	      yyres[yyn] = '\0';
-	    return yyn;
-	  }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-/* Copy into YYRESULT an error message about the unexpected token
-   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
-   including the terminating null byte.  If YYRESULT is null, do not
-   copy anything; just return the number of bytes that would be
-   copied.  As a special case, return 0 if an ordinary "syntax error"
-   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
-   size calculation.  */
-static YYSIZE_T
-yysyntax_error (char *yyresult, int yystate, int yychar)
-{
-  int yyn = yypact[yystate];
-
-  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
-    return 0;
-  else
-    {
-      int yytype = YYTRANSLATE (yychar);
-      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
-      YYSIZE_T yysize = yysize0;
-      YYSIZE_T yysize1;
-      int yysize_overflow = 0;
-      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-      int yyx;
-
-# if 0
-      /* This is so xgettext sees the translatable formats that are
-	 constructed on the fly.  */
-      YY_("syntax error, unexpected %s");
-      YY_("syntax error, unexpected %s, expecting %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
-# endif
-      char *yyfmt;
-      char const *yyf;
-      static char const yyunexpected[] = "syntax error, unexpected %s";
-      static char const yyexpecting[] = ", expecting %s";
-      static char const yyor[] = " or %s";
-      char yyformat[sizeof yyunexpected
-		    + sizeof yyexpecting - 1
-		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
-		       * (sizeof yyor - 1))];
-      char const *yyprefix = yyexpecting;
-
-      /* Start YYX at -YYN if negative to avoid negative indexes in
-	 YYCHECK.  */
-      int yyxbegin = yyn < 0 ? -yyn : 0;
-
-      /* Stay within bounds of both yycheck and yytname.  */
-      int yychecklim = YYLAST - yyn + 1;
-      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-      int yycount = 1;
-
-      yyarg[0] = yytname[yytype];
-      yyfmt = yystpcpy (yyformat, yyunexpected);
-
-      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	  {
-	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-	      {
-		yycount = 1;
-		yysize = yysize0;
-		yyformat[sizeof yyunexpected - 1] = '\0';
-		break;
-	      }
-	    yyarg[yycount++] = yytname[yyx];
-	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-	    yysize_overflow |= (yysize1 < yysize);
-	    yysize = yysize1;
-	    yyfmt = yystpcpy (yyfmt, yyprefix);
-	    yyprefix = yyor;
-	  }
-
-      yyf = YY_(yyformat);
-      yysize1 = yysize + yystrlen (yyf);
-      yysize_overflow |= (yysize1 < yysize);
-      yysize = yysize1;
-
-      if (yysize_overflow)
-	return YYSIZE_MAXIMUM;
-
-      if (yyresult)
-	{
-	  /* Avoid sprintf, as that infringes on the user's name space.
-	     Don't have undefined behavior even if the translation
-	     produced a string with the wrong number of "%s"s.  */
-	  char *yyp = yyresult;
-	  int yyi = 0;
-	  while ((*yyp = *yyf) != '\0')
-	    {
-	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
-		{
-		  yyp += yytnamerr (yyp, yyarg[yyi++]);
-		  yyf += 2;
-		}
-	      else
-		{
-		  yyp++;
-		  yyf++;
-		}
-	    }
-	}
-      return yysize;
-    }
-}
-#endif /* YYERROR_VERBOSE */
-
-
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yymsg, yytype, yyvaluep)
-    const char *yymsg;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  YYUSE (yyvaluep);
-
-  if (!yymsg)
-    yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
-
-  switch (yytype)
-    {
-
-      default:
-	break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-
-#ifdef YYPARSE_PARAM
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void *YYPARSE_PARAM);
-#else
-int yyparse ();
-#endif
-#else /* ! YYPARSE_PARAM */
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-
-/* The look-ahead symbol.  */
-int yychar;
-
-/* The semantic value of the look-ahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
+#endif
 
+/* Suppress unused-variable warnings by "using" E.  */
+#define YYUSE(e) ((void) (e))
 
-/*----------.
-| yyparse.  |
-`----------*/
+/* A pseudo ostream that takes yydebug_ into account.  */
+# define YYCDEBUG							\
+  for (bool yydebugcond_ = yydebug_; yydebugcond_; yydebugcond_ = false)	\
+    (*yycdebug_)
 
-#ifdef YYPARSE_PARAM
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void *YYPARSE_PARAM)
-#else
-int
-yyparse (YYPARSE_PARAM)
-    void *YYPARSE_PARAM;
-#endif
-#else /* ! YYPARSE_PARAM */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void)
-#else
-int
-yyparse ()
+/* Enable debugging if requested.  */
+#if YYDEBUG
 
-#endif
-#endif
-{
-  
-  int yystate;
-  int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Look-ahead token as an internal (translated) token number.  */
-  int yytoken = 0;
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)	\
+do {							\
+  if (yydebug_)						\
+    {							\
+      *yycdebug_ << Title << ' ';			\
+      yy_symbol_print_ ((Type), (Value), (Location));	\
+      *yycdebug_ << std::endl;				\
+    }							\
+} while (false)
 
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug_)				\
+    yy_reduce_print_ (Rule);		\
+} while (false)
 
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
+# define YY_STACK_PRINT()		\
+do {					\
+  if (yydebug_)				\
+    yystack_print_ ();			\
+} while (false)
 
-  /* The state stack.  */
-  yytype_int16 yyssa[YYINITDEPTH];
-  yytype_int16 *yyss = yyssa;
-  yytype_int16 *yyssp;
+#else /* !YYDEBUG */
 
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  YYSTYPE *yyvsp;
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_REDUCE_PRINT(Rule)
+# define YY_STACK_PRINT()
 
+#endif /* !YYDEBUG */
 
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
 
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+namespace QMake
+{
+#if YYERROR_VERBOSE
 
-  YYSIZE_T yystacksize = YYINITDEPTH;
+  /* Return YYSTR after stripping away unnecessary quotes and
+     backslashes, so that it's suitable for yyerror.  The heuristic is
+     that double-quoting is unnecessary unless the string contains an
+     apostrophe, a comma, or backslash (other than backslash-backslash).
+     YYSTR is taken from yytname.  */
+  std::string
+  Parser::yytnamerr_ (const char *yystr)
+  {
+    if (*yystr == '"')
+      {
+        std::string yyr = "";
+        char const *yyp = yystr;
 
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
+        for (;;)
+          switch (*++yyp)
+            {
+            case '\'':
+            case ',':
+              goto do_not_strip_quotes;
+
+            case '\\':
+              if (*++yyp != '\\')
+                goto do_not_strip_quotes;
+              /* Fall through.  */
+            default:
+              yyr += *yyp;
+              break;
 
+            case '"':
+              return yyr;
+            }
+      do_not_strip_quotes: ;
+      }
 
-  /* The number of symbols on the RHS of the reduced rule.
-     Keep to zero when no symbol should be popped.  */
-  int yylen = 0;
+    return yystr;
+  }
 
-  YYDPRINTF ((stderr, "Starting parse\n"));
+#endif
 
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+  /// Build a parser object.
+  Parser::Parser (QMake::Lexer* lexer_yyarg, QValueStack<ProjectAST*>& projects_yyarg, int depth_yyarg)
+    : yydebug_ (false),
+      yycdebug_ (&std::cerr),
+      lexer (lexer_yyarg),
+      projects (projects_yyarg),
+      depth (depth_yyarg)
+  {
+  }
+
+  Parser::~Parser ()
+  {
+  }
 
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
+#if YYDEBUG
+  /*--------------------------------.
+  | Print this symbol on YYOUTPUT.  |
+  `--------------------------------*/
+
+  inline void
+  Parser::yy_symbol_value_print_ (int yytype,
+			   const semantic_type* yyvaluep, const location_type* yylocationp)
+  {
+    YYUSE (yylocationp);
+    YYUSE (yyvaluep);
+    switch (yytype)
+      {
+         default:
+	  break;
+      }
+  }
 
-  yyssp = yyss;
-  yyvsp = yyvs;
 
-  goto yysetstate;
+  void
+  Parser::yy_symbol_print_ (int yytype,
+			   const semantic_type* yyvaluep, const location_type* yylocationp)
+  {
+    *yycdebug_ << (yytype < yyntokens_ ? "token" : "nterm")
+	       << ' ' << yytname_[yytype] << " ("
+	       << *yylocationp << ": ";
+    yy_symbol_value_print_ (yytype, yyvaluep, yylocationp);
+    *yycdebug_ << ')';
+  }
+#endif /* ! YYDEBUG */
+
+  void
+  Parser::yydestruct_ (const char* yymsg,
+			   int yytype, semantic_type* yyvaluep, location_type* yylocationp)
+  {
+    YYUSE (yylocationp);
+    YYUSE (yymsg);
+    YYUSE (yyvaluep);
 
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed.  So pushing a state here evens the stacks.  */
-  yyssp++;
+    YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
- yysetstate:
-  *yyssp = yystate;
+    switch (yytype)
+      {
+  
+	default:
+	  break;
+      }
+  }
 
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
+  void
+  Parser::yypop_ (unsigned int n)
+  {
+    yystate_stack_.pop (n);
+    yysemantic_stack_.pop (n);
+    yylocation_stack_.pop (n);
+  }
+
+  std::ostream&
+  Parser::debug_stream () const
+  {
+    return *yycdebug_;
+  }
+
+  void
+  Parser::set_debug_stream (std::ostream& o)
+  {
+    yycdebug_ = &o;
+  }
+
+
+  Parser::debug_level_type
+  Parser::debug_level () const
+  {
+    return yydebug_;
+  }
+
+  void
+  Parser::set_debug_level (debug_level_type l)
+  {
+    yydebug_ = l;
+  }
+
+
+  int
+  Parser::parse ()
+  {
+    /// Look-ahead and look-ahead in internal form.
+    int yychar = yyempty_;
+    int yytoken = 0;
+
+    /* State.  */
+    int yyn;
+    int yylen = 0;
+    int yystate = 0;
+
+    /* Error handling.  */
+    int yynerrs_ = 0;
+    int yyerrstatus_ = 0;
+
+    /// Semantic value of the look-ahead.
+    semantic_type yylval;
+    /// Location of the look-ahead.
+    location_type yylloc;
+    /// The locations where the error started and ended.
+    location yyerror_range[2];
+
+    /// $$.
+    semantic_type yyval;
+    /// @$.
+    location_type yyloc;
+
+    int yyresult;
+
+    YYCDEBUG << "Starting parse" << std::endl;
+
+
+    /* Initialize the stacks.  The initial state will be pushed in
+       yynewstate, since the latter expects the semantical and the
+       location values to have been already stored, initialize these
+       stacks with a primary value.  */
+    yystate_stack_ = state_stack_type (0);
+    yysemantic_stack_ = semantic_stack_type (0);
+    yylocation_stack_ = location_stack_type (0);
+    yysemantic_stack_.push (yylval);
+    yylocation_stack_.push (yylloc);
+
+    /* New state.  */
+  yynewstate:
+    yystate_stack_.push (yystate);
+    YYCDEBUG << "Entering state " << yystate << std::endl;
+    goto yybackup;
+
+    /* Backup.  */
+  yybackup:
+
+    /* Try to take a decision without look-ahead.  */
+    yyn = yypact_[yystate];
+    if (yyn == yypact_ninf_)
+      goto yydefault;
 
-#ifdef yyoverflow
+    /* Read a look-ahead token.  */
+    if (yychar == yyempty_)
       {
-	/* Give user a chance to reallocate the stack.  Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	yytype_int16 *yyss1 = yyss;
-
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow (YY_("memory exhausted"),
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
+	YYCDEBUG << "Reading a token: ";
+	yychar = yylex (&yylval, lexer);
+      }
 
-		    &yystacksize);
 
-	yyss = yyss1;
-	yyvs = yyvs1;
+    /* Convert token to internal form.  */
+    if (yychar <= yyeof_)
+      {
+	yychar = yytoken = yyeof_;
+	YYCDEBUG << "Now at end of input." << std::endl;
       }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyexhaustedlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
+    else
       {
-	yytype_int16 *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
+	yytoken = yytranslate_ (yychar);
+	YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
       }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
 
-  /* Do appropriate processing given the current state.  Read a
-     look-ahead token if we need one and don't already have one.  */
-
-  /* First try to decide what to do without reference to look-ahead token.  */
-  yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
-    goto yydefault;
-
-  /* Not known => get a look-ahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
+    /* If the proper action on seeing token YYTOKEN is to reduce or to
+       detect an error, take that action.  */
+    yyn += yytoken;
+    if (yyn < 0 || yylast_ < yyn || yycheck_[yyn] != yytoken)
+      goto yydefault;
+
+    /* Reduce or error.  */
+    yyn = yytable_[yyn];
+    if (yyn <= 0)
+      {
+	if (yyn == 0 || yyn == yytable_ninf_)
 	goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  /* Shift the look-ahead token.  */
-  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  yystate = yyn;
-  *++yyvsp = yylval;
-
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
+	yyn = -yyn;
+	goto yyreduce;
+      }
 
+    /* Accept?  */
+    if (yyn == yyfinal_)
+      goto yyacceptlab;
+
+    /* Shift the look-ahead token.  */
+    YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+    /* Discard the token being shifted unless it is eof.  */
+    if (yychar != yyeof_)
+      yychar = yyempty_;
+
+    yysemantic_stack_.push (yylval);
+    yylocation_stack_.push (yylloc);
+
+    /* Count tokens shifted since error; after three, turn off error
+       status.  */
+    if (yyerrstatus_)
+      --yyerrstatus_;
+
+    yystate = yyn;
+    goto yynewstate;
+
+  /*-----------------------------------------------------------.
+  | yydefault -- do the default action for the current state.  |
+  `-----------------------------------------------------------*/
+  yydefault:
+    yyn = yydefact_[yystate];
+    if (yyn == 0)
+      goto yyerrlab;
+    goto yyreduce;
+
+  /*-----------------------------.
+  | yyreduce -- Do a reduction.  |
+  `-----------------------------*/
+  yyreduce:
+    yylen = yyr2_[yyn];
+    /* If YYLEN is nonzero, implement the default value of the action:
+       `$$ = $1'.  Otherwise, use the top of the stack.
+
+       Otherwise, the following line sets YYVAL to garbage.
+       This behavior is undocumented and Bison
+       users should not rely upon it.  */
+    if (yylen)
+      yyval = yysemantic_stack_[yylen - 1];
+    else
+      yyval = yysemantic_stack_[0];
 
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
     {
-        case 2:
-#line 136 "qmake.yy"
+      slice<location_type, location_stack_type> slice (yylocation_stack_, yylen);
+      YYLLOC_DEFAULT (yyloc, slice, yylen);
+    }
+    YY_REDUCE_PRINT (yyn);
+    switch (yyn)
+      {
+	  case 2:
+#line 147 "qmake.yy"
     {
         ProjectAST *projectAST = new ProjectAST();
         projects.push(projectAST);
@@ -1510,73 +396,73 @@ yyreduce:
     break;
 
   case 4:
-#line 144 "qmake.yy"
+#line 155 "qmake.yy"
     {
-            projects.top()->addChildAST((yyvsp[(2) - (2)].node));
-            (yyvsp[(2) - (2)].node)->setDepth(depth);
+            projects.top()->addChildAST((yysemantic_stack_[(2) - (2)].node));
+            (yysemantic_stack_[(2) - (2)].node)->setDepth(depth);
         ;}
     break;
 
   case 6:
-#line 152 "qmake.yy"
+#line 163 "qmake.yy"
     {
-            (yyval.node) = (yyvsp[(1) - (1)].node);
+            (yyval.node) = (yysemantic_stack_[(1) - (1)].node);
         ;}
     break;
 
   case 7:
-#line 156 "qmake.yy"
+#line 167 "qmake.yy"
     {
-            (yyval.node) = (yyvsp[(1) - (1)].node);
+            (yyval.node) = (yysemantic_stack_[(1) - (1)].node);
         ;}
     break;
 
   case 8:
-#line 160 "qmake.yy"
+#line 171 "qmake.yy"
     {
-            (yyval.node) = (yyvsp[(1) - (1)].node);
+            (yyval.node) = (yysemantic_stack_[(1) - (1)].node);
         ;}
     break;
 
   case 9:
-#line 164 "qmake.yy"
+#line 175 "qmake.yy"
     {
-            (yyval.node) = (yyvsp[(1) - (1)].node);
+            (yyval.node) = (yysemantic_stack_[(1) - (1)].node);
         ;}
     break;
 
   case 10:
-#line 168 "qmake.yy"
+#line 179 "qmake.yy"
     {
             (yyval.node) = new NewLineAST();
         ;}
     break;
 
   case 11:
-#line 174 "qmake.yy"
+#line 185 "qmake.yy"
     {
             AssignmentAST *node = new AssignmentAST();
-            node->scopedID = (yyvsp[(1) - (3)].value);
-            node->op = (yyvsp[(2) - (3)].value);
-            node->values = (yyvsp[(3) - (3)].values);
-            node->indent = (yyvsp[(3) - (3)].indent);
-	        node->commentnode = (yyvsp[(3) - (3)].node);
+            node->scopedID = (yysemantic_stack_[(3) - (1)].value);
+            node->op = (yysemantic_stack_[(3) - (2)].value);
+            node->values = (yysemantic_stack_[(3) - (3)].values);
+            node->indent = (yysemantic_stack_[(3) - (3)].indent);
+	        node->commentnode = (yysemantic_stack_[(3) - (3)].node);
             (yyval.node) = node;
         ;}
     break;
 
   case 12:
-#line 186 "qmake.yy"
+#line 197 "qmake.yy"
     {
-            (yyval.values) += (yyvsp[(2) - (3)].values);
-            if( (yyvsp[(2) - (3)].indent) != "" && (yyval.indent) == "" )
-                (yyval.indent) = (yyvsp[(2) - (3)].indent);
-            (yyval.node) = (yyvsp[(3) - (3)].node);
+            (yyval.values) += (yysemantic_stack_[(3) - (2)].values);
+            if( (yysemantic_stack_[(3) - (2)].indent) != "" && (yyval.indent) == "" )
+                (yyval.indent) = (yysemantic_stack_[(3) - (2)].indent);
+            (yyval.node) = (yysemantic_stack_[(3) - (3)].node);
         ;}
     break;
 
   case 13:
-#line 193 "qmake.yy"
+#line 204 "qmake.yy"
     {
             (yyval.values).clear();
             (yyval.indent) = "";
@@ -1585,77 +471,77 @@ yyreduce:
     break;
 
   case 14:
-#line 200 "qmake.yy"
-    { (yyval.values).append( (yyvsp[(2) - (2)].value) ); ;}
+#line 211 "qmake.yy"
+    { (yyval.values).append( (yysemantic_stack_[(2) - (2)].value) ); ;}
     break;
 
   case 15:
-#line 201 "qmake.yy"
-    { (yyval.values).append( (yyvsp[(1) - (1)].value) ); ;}
+#line 212 "qmake.yy"
+    { (yyval.values).append( (yysemantic_stack_[(1) - (1)].value) ); ;}
     break;
 
   case 16:
-#line 202 "qmake.yy"
+#line 213 "qmake.yy"
     { (yyval.values).append("\\\n"); ;}
     break;
 
   case 17:
-#line 203 "qmake.yy"
+#line 214 "qmake.yy"
     { (yyval.values).append("\n"); ;}
     break;
 
   case 18:
-#line 204 "qmake.yy"
-    { (yyval.values).append((yyvsp[(1) - (1)].value)); ;}
+#line 215 "qmake.yy"
+    { (yyval.values).append((yysemantic_stack_[(1) - (1)].value)); ;}
     break;
 
   case 19:
-#line 206 "qmake.yy"
+#line 217 "qmake.yy"
     {
-            (yyval.values).append((yyvsp[(1) - (1)].value));
-            if( (yyval.indent) == "" && (yyvsp[(1) - (1)].value) != "" )
-                (yyval.indent) = (yyvsp[(1) - (1)].value);
+            (yyval.values).append((yysemantic_stack_[(1) - (1)].value));
+            if( (yyval.indent) == "" && (yysemantic_stack_[(1) - (1)].value) != "" )
+                (yyval.indent) = (yysemantic_stack_[(1) - (1)].value);
         ;}
     break;
 
   case 22:
-#line 216 "qmake.yy"
+#line 227 "qmake.yy"
     {
             CommentAST* node = new CommentAST();
-            node->comment = (yyvsp[(1) - (1)].value) + "\n";
+            node->comment = (yysemantic_stack_[(1) - (1)].value) + "\n";
 	        (yyval.node) = node;
         ;}
     break;
 
   case 23:
-#line 222 "qmake.yy"
+#line 233 "qmake.yy"
     {
             (yyval.node) = 0;
         ;}
     break;
 
   case 24:
-#line 227 "qmake.yy"
-    { (yyval.value) = (yyvsp[(1) - (1)].value); ;}
+#line 238 "qmake.yy"
+    { (yyval.value) = (yysemantic_stack_[(1) - (1)].value); ;}
     break;
 
   case 25:
-#line 228 "qmake.yy"
-    { (yyval.value) = (yyvsp[(1) - (1)].value); ;}
+#line 239 "qmake.yy"
+    { (yyval.value) = (yysemantic_stack_[(1) - (1)].value); ;}
     break;
 
   case 31:
-#line 235 "qmake.yy"
+#line 246 "qmake.yy"
     {
             ProjectAST *projectAST = new ProjectAST(ProjectAST::Scope);
             projects.push(projectAST);
-            projects.top()->scopedID = (yyvsp[(1) - (1)].value);
+            projects.top()->scopedID = (yysemantic_stack_[(1) - (1)].value);
             depth++;
         ;}
     break;
 
   case 32:
-#line 242 "qmake.yy"
+#line 253 "qmake.yy"
     {
             (yyval.node) = projects.pop();
             depth--;
@@ -1663,19 +549,19 @@ yyreduce:
     break;
 
   case 33:
-#line 249 "qmake.yy"
+#line 260 "qmake.yy"
     {
             ProjectAST *projectAST = new ProjectAST(ProjectAST::FunctionScope);
             projects.push(projectAST);
-            projects.top()->scopedID = (yyvsp[(1) - (4)].value);
-            projects.top()->args = (yyvsp[(3) - (4)].value);
+            projects.top()->scopedID = (yysemantic_stack_[(4) - (1)].value);
+            projects.top()->args = (yysemantic_stack_[(4) - (3)].value);
             depth++;
 
             //qWarning("%s", $<value>1.ascii());
-            if ((yyvsp[(1) - (4)].value).contains("include"))
+            if ((yysemantic_stack_[(4) - (1)].value).contains("include"))
             {
                 IncludeAST *includeAST = new IncludeAST();
-                includeAST->projectName = (yyvsp[(3) - (4)].value);
+                includeAST->projectName = (yysemantic_stack_[(4) - (3)].value);
                 projects.top()->addChildAST(includeAST);
                 includeAST->setDepth(depth);
             }
@@ -1683,7 +569,7 @@ yyreduce:
     break;
 
   case 34:
-#line 267 "qmake.yy"
+#line 278 "qmake.yy"
     {
             (yyval.node) = projects.pop();
             depth--;
@@ -1691,25 +577,25 @@ yyreduce:
     break;
 
   case 35:
-#line 273 "qmake.yy"
-    { (yyval.value) = (yyvsp[(1) - (1)].value); ;}
+#line 284 "qmake.yy"
+    { (yyval.value) = (yysemantic_stack_[(1) - (1)].value); ;}
     break;
 
   case 36:
-#line 274 "qmake.yy"
+#line 285 "qmake.yy"
     { (yyval.value) = ""; ;}
     break;
 
   case 38:
-#line 279 "qmake.yy"
+#line 290 "qmake.yy"
     {
-            projects.top()->addChildAST((yyvsp[(2) - (2)].node));
-            (yyvsp[(2) - (2)].node)->setDepth(depth);
+            projects.top()->addChildAST((yysemantic_stack_[(2) - (2)].node));
+            (yysemantic_stack_[(2) - (2)].node)->setDepth(depth);
         ;}
     break;
 
   case 40:
-#line 287 "qmake.yy"
+#line 298 "qmake.yy"
     {
             ProjectAST *projectAST = new ProjectAST(ProjectAST::FunctionScope);
             projects.push(projectAST);
@@ -1720,7 +606,7 @@ yyreduce:
     break;
 
   case 41:
-#line 295 "qmake.yy"
+#line 306 "qmake.yy"
     {
             (yyval.node) = projects.pop();
             depth--;
@@ -1728,239 +614,499 @@ yyreduce:
     break;
 
   case 42:
-#line 300 "qmake.yy"
+#line 311 "qmake.yy"
     {
             (yyval.node) = new ProjectAST();
         ;}
     break;
 
   case 43:
-#line 306 "qmake.yy"
+#line 317 "qmake.yy"
     {
             CommentAST *node = new CommentAST();
-            node->comment = (yyvsp[(1) - (2)].value) + "\n";
+            node->comment = (yysemantic_stack_[(2) - (1)].value) + "\n";
             (yyval.node) = node;
         ;}
     break;
 
 
-/* Line 1267 of yacc.c.  */
-#line 1749 "qmake_yacc.cpp"
-      default: break;
-    }
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
-
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
+    /* Line 675 of lalr1.cc.  */
+#line 635 "qmake_yacc.cpp"
+	default: break;
+      }
+    YY_SYMBOL_PRINT ("-> $$ =", yyr1_[yyn], &yyval, &yyloc);
 
+    yypop_ (yylen);
+    yylen = 0;
+    YY_STACK_PRINT ();
+
+    yysemantic_stack_.push (yyval);
+    yylocation_stack_.push (yyloc);
+
+    /* Shift the result of the reduction.  */
+    yyn = yyr1_[yyn];
+    yystate = yypgoto_[yyn - yyntokens_] + yystate_stack_[0];
+    if (0 <= yystate && yystate <= yylast_
+	&& yycheck_[yystate] == yystate_stack_[0])
+      yystate = yytable_[yystate];
+    else
+      yystate = yydefgoto_[yyn - yyntokens_];
+    goto yynewstate;
+
+  /*------------------------------------.
+  | yyerrlab -- here on detecting error |
+  `------------------------------------*/
+  yyerrlab:
+    /* If not already recovering from an error, report this error.  */
+    if (!yyerrstatus_)
+      {
+	++yynerrs_;
+	error (yylloc, yysyntax_error_ (yystate));
+      }
 
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if ! YYERROR_VERBOSE
-      yyerror (YY_("syntax error"));
-#else
+    yyerror_range[0] = yylloc;
+    if (yyerrstatus_ == 3)
       {
-	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
-	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
-	  {
-	    YYSIZE_T yyalloc = 2 * yysize;
-	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
-	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
-	    if (yymsg != yymsgbuf)
-	      YYSTACK_FREE (yymsg);
-	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
-	    if (yymsg)
-	      yymsg_alloc = yyalloc;
-	    else
-	      {
-		yymsg = yymsgbuf;
-		yymsg_alloc = sizeof yymsgbuf;
-	      }
-	  }
+	/* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
 
-	if (0 < yysize && yysize <= yymsg_alloc)
+	if (yychar <= yyeof_)
 	  {
-	    (void) yysyntax_error (yymsg, yystate, yychar);
-	    yyerror (yymsg);
+	  /* Return failure if at end of input.  */
+	  if (yychar == yyeof_)
+	    YYABORT;
 	  }
 	else
 	  {
-	    yyerror (YY_("syntax error"));
-	    if (yysize != 0)
-	      goto yyexhaustedlab;
+	    yydestruct_ ("Error: discarding", yytoken, &yylval, &yylloc);
+	    yychar = yyempty_;
 	  }
       }
-#endif
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse look-ahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-	{
-	  /* Return failure if at end of input.  */
-	  if (yychar == YYEOF)
-	    YYABORT;
-	}
-      else
-	{
-	  yydestruct ("Error: discarding",
-		      yytoken, &yylval);
-	  yychar = YYEMPTY;
-	}
-    }
 
-  /* Else will try to reuse look-ahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
-
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYERROR.  */
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+    /* Else will try to reuse look-ahead token after shifting the error
+       token.  */
+    goto yyerrlab1;
+
+
+  /*---------------------------------------------------.
+  | yyerrorlab -- error raised explicitly by YYERROR.  |
+  `---------------------------------------------------*/
+  yyerrorlab:
+
+    /* Pacify compilers like GCC when the user code never invokes
+       YYERROR and the label yyerrorlab therefore never appears in user
+       code.  */
+    if (false)
+      goto yyerrorlab;
+
+    yyerror_range[0] = yylocation_stack_[yylen - 1];
+    /* Do not reclaim the symbols of the rule which action triggered
+       this YYERROR.  */
+    yypop_ (yylen);
+    yylen = 0;
+    yystate = yystate_stack_[0];
+    goto yyerrlab1;
+
+  /*-------------------------------------------------------------.
+  | yyerrlab1 -- common code for both syntax error and YYERROR.  |
+  `-------------------------------------------------------------*/
+  yyerrlab1:
+    yyerrstatus_ = 3;	/* Each real token shifted decrements this.  */
 
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
+    for (;;)
+      {
+	yyn = yypact_[yystate];
+	if (yyn != yypact_ninf_)
 	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	  yyn += yyterror_;
+	  if (0 <= yyn && yyn <= yylast_ && yycheck_[yyn] == yyterror_)
 	    {
-	      yyn = yytable[yyn];
+	      yyn = yytable_[yyn];
 	      if (0 < yyn)
 		break;
 	    }
 	}
 
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
+	/* Pop the current state because it cannot handle the error token.  */
+	if (yystate_stack_.height () == 1)
 	YYABORT;
 
+	yyerror_range[0] = yylocation_stack_[0];
+	yydestruct_ ("Error: popping",
+		     yystos_[yystate],
+		     &yysemantic_stack_[0], &yylocation_stack_[0]);
+	yypop_ ();
+	yystate = yystate_stack_[0];
+	YY_STACK_PRINT ();
+      }
+
+    if (yyn == yyfinal_)
+      goto yyacceptlab;
 
-      yydestruct ("Error: popping",
-		  yystos[yystate], yyvsp);
-      YYPOPSTACK (1);
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
+    yyerror_range[1] = yylloc;
+    // Using YYLLOC is tempting, but would change the location of
+    // the look-ahead.  YYLOC is available though.
+    YYLLOC_DEFAULT (yyloc, (yyerror_range - 1), 2);
+    yysemantic_stack_.push (yylval);
+    yylocation_stack_.push (yyloc);
+
+    /* Shift the error token.  */
+    YY_SYMBOL_PRINT ("Shifting", yystos_[yyn],
+		   &yysemantic_stack_[0], &yylocation_stack_[0]);
+
+    yystate = yyn;
+    goto yynewstate;
+
+    /* Accept.  */
+  yyacceptlab:
+    yyresult = 0;
+    goto yyreturn;
+
+    /* Abort.  */
+  yyabortlab:
+    yyresult = 1;
+    goto yyreturn;
+
+  yyreturn:
+    if (yychar != yyeof_ && yychar != yyempty_)
+      yydestruct_ ("Cleanup: discarding lookahead", yytoken, &yylval, &yylloc);
+
+    /* Do not reclaim the symbols of the rule which action triggered
+       this YYABORT or YYACCEPT.  */
+    yypop_ (yylen);
+    while (yystate_stack_.height () != 1)
+      {
+	yydestruct_ ("Cleanup: popping",
+		   yystos_[yystate_stack_[0]],
+		   &yysemantic_stack_[0],
+		   &yylocation_stack_[0]);
+	yypop_ ();
+      }
+
+    return yyresult;
+  }
+
+  // Generate an error message.
+  std::string
+  Parser::yysyntax_error_ (int yystate)
+  {
+    std::string res;
+    YYUSE (yystate);
+#if YYERROR_VERBOSE
+    int yyn = yypact_[yystate];
+    if (yypact_ninf_ < yyn && yyn <= yylast_)
+      {
+	/* Start YYX at -YYN if negative to avoid negative indexes in
+	   YYCHECK.  */
+	int yyxbegin = yyn < 0 ? -yyn : 0;
+
+	/* Stay within bounds of both yycheck and yytname.  */
+	int yychecklim = yylast_ - yyn + 1;
+	int yyxend = yychecklim < yyntokens_ ? yychecklim : yyntokens_;
+	int count = 0;
+	for (int x = yyxbegin; x < yyxend; ++x)
+	  if (yycheck_[x + yyn] == x && x != yyterror_)
+	    ++count;
+
+	// FIXME: This method of building the message is not compatible
+	// with internationalization.  It should work like yacc.c does it.
+	// That is, first build a string that looks like this:
+	// "syntax error, unexpected %s or %s or %s"
+	// Then, invoke YY_ on this string.
+	// Finally, use the string as a format to output
+	// yytname_[tok], etc.
+	// Until this gets fixed, this message appears in English only.
+	res = "syntax error, unexpected ";
+	res += yytnamerr_ (yytname_[tok]);
+	if (count < 5)
+	  {
+	    count = 0;
+	    for (int x = yyxbegin; x < yyxend; ++x)
+	      if (yycheck_[x + yyn] == x && x != yyterror_)
+		{
+		  res += (!count++) ? ", expecting " : " or ";
+		  res += yytnamerr_ (yytname_[x]);
+		}
+	  }
+      }
+    else
+#endif
+      res = YY_("syntax error");
+    return res;
+  }
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
 
-  *++yyvsp = yylval;
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+  const signed char Parser::yypact_ninf_ = -41;
+  const signed char
+  Parser::yypact_[] =
+  {
+       -41,     1,   -41,   -41,     5,    18,   -41,    -9,   -41,   -41,
+     -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,   -14,
+     -41,    -2,   -41,   -41,    21,   -10,     5,   -41,   -41,   -41,
+     -41,   -41,   -41,   -41,   -41,   -41,   -41,   -41,     7,   -41,
+     -41,     4,    -2,   -41,   -41,   -41,   -41,     6,    15,   -41,
+     -41,    -2,    17,   -41
+  };
+
+  /* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+     doesn't specify something else to do.  Zero means the default is an
+     error.  */
+  const unsigned char
+  Parser::yydefact_[] =
+  {
+         2,     0,     5,     1,     3,    31,    44,     0,     4,     6,
+       7,     8,     9,    10,    26,    27,    28,    29,    30,    36,
+      13,    39,    43,    35,     0,    11,     0,     5,    32,    33,
+      21,    17,    16,    20,    25,    24,    19,    18,    23,    15,
+      38,     0,    39,    22,    12,    14,    37,    42,     0,    34,
+      40,    39,     0,    41
+  };
 
+  /* YYPGOTO[NTERM-NUM].  */
+  const signed char
+  Parser::yypgoto_[] =
+  {
+       -41,   -41,   -41,     8,    10,   -41,   -41,   -41,   -41,    -1,
+     -41,   -41,   -41,   -41,   -41,   -41,   -40,   -41,   -41,   -41,
+     -41
+  };
 
-  /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+  /* YYDEFGOTO[NTERM-NUM].  */
+  const signed char
+  Parser::yydefgoto_[] =
+  {
+        -1,     1,     2,     4,     8,     9,    25,    38,    44,    39,
+      20,    10,    21,    11,    42,    24,    28,    49,    51,    12,
+      13
+  };
 
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#ifndef yyoverflow
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-yyexhaustedlab:
-  yyerror (YY_("memory exhausted"));
-  yyresult = 2;
-  /* Fall through.  */
-#endif
+  /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule which
+     number is the opposite.  If zero, do what YYDEFACT says.  */
+  const signed char Parser::yytable_ninf_ = -1;
+  const unsigned char
+  Parser::yytable_[] =
+  {
+        30,     3,    47,    31,    22,    23,    32,     5,     5,    26,
+      33,    52,    34,    35,    36,    37,    27,     6,     6,     7,
+       7,    46,    14,    15,    16,    17,    18,    19,    43,    34,
+      35,    29,    48,    50,    53,    41,    40,    45
+  };
 
-yyreturn:
-  if (yychar != YYEOF && yychar != YYEMPTY)
-     yydestruct ("Cleanup: discarding lookahead",
-		 yytoken, &yylval);
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYABORT or YYACCEPT.  */
-  YYPOPSTACK (yylen);
-  YY_STACK_PRINT (yyss, yyssp);
-  while (yyssp != yyss)
-    {
-      yydestruct ("Cleanup: popping",
-		  yystos[*yyssp], yyvsp);
-      YYPOPSTACK (1);
-    }
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
+  /* YYCHECK.  */
+  const unsigned char
+  Parser::yycheck_[] =
+  {
+        10,     0,    42,    13,    13,    19,    16,     3,     3,    11,
+      20,    51,    22,    23,    24,    25,    18,    13,    13,    15,
+      15,    17,     4,     5,     6,     7,     8,     9,    21,    22,
+      23,    10,    26,    18,    17,    27,    26,    38
+  };
+
+  /* STOS_[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+  const unsigned char
+  Parser::yystos_[] =
+  {
+         0,    28,    29,     0,    30,     3,    13,    15,    31,    32,
+      38,    40,    46,    47,     4,     5,     6,     7,     8,     9,
+      37,    39,    13,    19,    42,    33,    11,    18,    43,    10,
+      10,    13,    16,    20,    22,    23,    24,    25,    34,    36,
+      31,    30,    41,    21,    35,    36,    17,    43,    26,    44,
+      18,    45,    43,    17
+  };
+
+#if YYDEBUG
+  /* TOKEN_NUMBER_[YYLEX-NUM] -- Internal symbol number corresponding
+     to YYLEX-NUM.  */
+  const unsigned short int
+  Parser::yytoken_number_[] =
+  {
+         0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281
+  };
 #endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+  const unsigned char
+  Parser::yyr1_[] =
+  {
+         0,    27,    29,    28,    30,    30,    31,    31,    31,    31,
+      31,    32,    33,    33,    34,    34,    34,    34,    34,    34,
+      34,    34,    35,    35,    36,    36,    37,    37,    37,    37,
+      37,    39,    38,    41,    40,    42,    42,    43,    43,    43,
+      45,    44,    44,    46,    47
+  };
+
+  /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+  const unsigned char
+  Parser::yyr2_[] =
+  {
+         0,     2,     0,     2,     2,     0,     1,     1,     1,     1,
+       1,     3,     3,     0,     2,     1,     1,     1,     1,     1,
+       1,     1,     1,     0,     1,     1,     1,     1,     1,     1,
+       1,     0,     3,     0,     7,     1,     0,     3,     2,     0,
+       0,     5,     0,     2,     1
+  };
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+  /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+     First, the terminals, then, starting at \a yyntokens_, nonterminals.  */
+  const char*
+  const Parser::yytname_[] =
+  {
+    "$end", "error", "$undefined", "ID_SIMPLE", "EQ", "PLUSEQ", "MINUSEQ",
+  "STAREQ", "TILDEEQ", "LBRACE", "RBRACE", "COLON", "NUMSIGN", "NEWLINE",
+  "NUMBER", "COMMENT", "CONT", "RCURLY", "LCURLY", "ID_ARGS",
+  "LIST_COMMENT", "LIST_COMMENT_WITHOUT_NEWLINE", "QUOTED_VARIABLE_VALUE",
+  "VARIABLE_VALUE", "INDENT", "LIST_WS", "\"else\"", "$accept", "project",
+  "@1", "statements", "statement", "variable_assignment",
+  "multiline_values", "line_body", "opt_comment", "variable_value",
+  "operator", "scope", "@2", "function_call", "@3", "function_args",
+  "scope_body", "else_statement", "@4", "comment", "emptyline", 0
+  };
 #endif
-  /* Make sure YYID is used.  */
-  return YYID (yyresult);
-}
 
+#if YYDEBUG
+  /* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+  const Parser::rhs_number_type
+  Parser::yyrhs_[] =
+  {
+        28,     0,    -1,    -1,    29,    30,    -1,    30,    31,    -1,
+      -1,    32,    -1,    38,    -1,    40,    -1,    46,    -1,    47,
+      -1,     3,    37,    33,    -1,    33,    34,    35,    -1,    -1,
+      34,    36,    -1,    36,    -1,    16,    -1,    13,    -1,    25,
+      -1,    24,    -1,    20,    -1,    10,    -1,    21,    -1,    -1,
+      23,    -1,    22,    -1,     4,    -1,     5,    -1,     6,    -1,
+       7,    -1,     8,    -1,    -1,     3,    39,    43,    -1,    -1,
+       3,     9,    42,    10,    41,    43,    44,    -1,    19,    -1,
+      -1,    18,    30,    17,    -1,    11,    31,    -1,    -1,    -1,
+      26,    18,    45,    43,    17,    -1,    -1,    15,    13,    -1,
+      13,    -1
+  };
+
+  /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+     YYRHS.  */
+  const unsigned char
+  Parser::yyprhs_[] =
+  {
+         0,     0,     3,     4,     7,    10,    11,    13,    15,    17,
+      19,    21,    25,    29,    30,    33,    35,    37,    39,    41,
+      43,    45,    47,    49,    50,    52,    54,    56,    58,    60,
+      62,    64,    65,    69,    70,    78,    80,    81,    85,    88,
+      89,    90,    96,    97,   100
+  };
+
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+  const unsigned short int
+  Parser::yyrline_[] =
+  {
+         0,   147,   147,   147,   154,   159,   162,   166,   170,   174,
+     178,   184,   196,   204,   211,   212,   213,   214,   215,   216,
+     222,   223,   226,   233,   238,   239,   242,   242,   242,   242,
+     242,   246,   245,   260,   259,   284,   285,   288,   289,   294,
+     298,   297,   311,   316,   324
+  };
+
+  // Print the state stack on the debug stream.
+  void
+  Parser::yystack_print_ ()
+  {
+    *yycdebug_ << "Stack now";
+    for (state_stack_type::const_iterator i = yystate_stack_.begin ();
+	 i != yystate_stack_.end (); ++i)
+      *yycdebug_ << ' ' << *i;
+    *yycdebug_ << std::endl;
+  }
+
+  // Report on the debug stream that the rule \a yyrule is going to be reduced.
+  void
+  Parser::yy_reduce_print_ (int yyrule)
+  {
+    unsigned int yylno = yyrline_[yyrule];
+    int yynrhs = yyr2_[yyrule];
+    /* Print the symbols being reduced, and their result.  */
+    *yycdebug_ << "Reducing stack by rule " << yyrule - 1
+	       << " (line " << yylno << "), ";
+    /* The symbols being reduced.  */
+    for (int yyi = 0; yyi < yynrhs; yyi++)
+      YY_SYMBOL_PRINT ("   $" << yyi + 1 << " =",
+		       yyrhs_[yyprhs_[yyrule] + yyi],
+		       &(yysemantic_stack_[(yynrhs) - (yyi + 1)]),
+		       &(yylocation_stack_[(yynrhs) - (yyi + 1)]));
+  }
+#endif // YYDEBUG
+
+  /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+  Parser::token_number_type
+  Parser::yytranslate_ (int t)
+  {
+    static
+    const token_number_type
+    translate_table[] =
+    {
+           0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26
+    };
+    if ((unsigned int) t <= yyuser_token_number_max_)
+      return translate_table[t];
+    else
+      return yyundef_token_;
+  }
+
+  const int Parser::yyeof_ = 0;
+  const int Parser::yylast_ = 37;
+  const int Parser::yynnts_ = 21;
+  const int Parser::yyempty_ = -2;
+  const int Parser::yyfinal_ = 3;
+  const int Parser::yyterror_ = 1;
+  const int Parser::yyerrcode_ = 256;
+  const int Parser::yyntokens_ = 27;
+
+  const unsigned int Parser::yyuser_token_number_max_ = 281;
+  const Parser::token_number_type Parser::yyundef_token_ = 2;
+
+} // namespace QMake
+
+#line 327 "qmake.yy"
 
-#line 316 "qmake.yy"
 
 
-#include "qmake_lex.cpp"
+namespace QMake
+{
+    void Parser::error(const location_type& /*l*/, const std::string& m)
+    {
+        std::cerr << m << std::endl;
+    }
+}
 
