$NetBSD: patch-aa,v 1.3 2003/04/11 20:26:31 jmmv Exp $

--- src/IO/http.c.orig	2003-03-04 20:34:59.000000000 +0100
+++ src/IO/http.c
@@ -246,10 +246,11 @@ static int Http_connect_socket(ChainLink
 {
    gint status;
 #ifdef ENABLE_IPV6
-   struct sockaddr_storage name;
-#else
-   struct sockaddr_in name;
+   struct sockaddr_in6 name6;
 #endif
+   struct sockaddr_in name4;
+   struct sockaddr *sa = NULL;
+   socklen_t sa_len = 0;
    SocketData_t *S;
    DilloHost *dh;
 
@@ -268,31 +269,35 @@ static int Http_connect_socket(ChainLink
    fcntl(S->SockFD, F_SETFD,
          FD_CLOEXEC | fcntl(S->SockFD, F_GETFD));
 
-   /* Some OSes require this...  */
-   memset(&name, 0, sizeof(name));
    /* Set remaining parms. */
    switch (dh->af) {
    case AF_INET:
    {
-      struct sockaddr_in *sin = (struct sockaddr_in *)&name;
+      struct sockaddr_in *sin = (struct sockaddr_in *)&name4;
+      memset(&name4, 0, sizeof(name4));
       sin->sin_family = dh->af;
       sin->sin_port = S->port ? htons(S->port) : htons(DILLO_URL_HTTP_PORT);
       memcpy(&sin->sin_addr, dh->data, dh->alen);
       if (a_Web_valid(S->web) && (S->web->flags & WEB_RootUrl))
          DEBUG_MSG(5, "Connecting to %s\n", inet_ntoa(sin->sin_addr));
+      sa = (struct sockaddr *)sin;
+      sa_len = sizeof(struct sockaddr_in);
       break;
    }
 #ifdef ENABLE_IPV6
    case AF_INET6:
    {
       char buf[128];
-      struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&name;
+      struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&name6;
+      memset(&name6, 0, sizeof(name6));
       sin6->sin6_family = dh->af;
       sin6->sin6_port = S->port ? htons(S->port) : htons(DILLO_URL_HTTP_PORT);
       memcpy(&sin6->sin6_addr, dh->data, dh->alen);
       inet_ntop(dh->af, dh->data, buf, sizeof(buf));
       if (a_Web_valid(S->web) && (S->web->flags & WEB_RootUrl))
          DEBUG_MSG(5, "Connecting to %s\n", buf);
+      sa = (struct sockaddr *)sin6;
+      sa_len = sizeof(struct sockaddr_in6);
       break;
    }
 #endif
@@ -302,7 +307,7 @@ static int Http_connect_socket(ChainLink
       S->GioCh = g_io_channel_unix_new(S->SockFD);
    g_io_add_watch(S->GioCh, G_IO_ERR | G_IO_HUP | G_IO_OUT,
                   Http_use_socket, Info->LocalKey);
-   status = connect(S->SockFD, (struct sockaddr *)&name, sizeof(name));
+   status = connect(S->SockFD, sa, sa_len);
    if ( status == -1 && errno != EINPROGRESS ) {
       S->Err = errno;
       return -1;
