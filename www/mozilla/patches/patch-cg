$NetBSD: patch-cg,v 1.4 2005/09/28 12:04:29 rillig Exp $

--- extensions/transformiix/source/base/Double.cpp.orig	2004-01-15 22:23:18.000000000 +0100
+++ extensions/transformiix/source/base/Double.cpp	2005-06-20 11:26:26.000000000 +0200
@@ -48,6 +48,38 @@
  * Utility class for doubles
  */
 
+#if defined(INFINITY) && defined(NAN)
+double Double::NaN()
+{
+	return NAN;
+}
+
+double Double::PositiveInfinity()
+{
+	return INFINITY;
+}
+
+double Double::NegativeInfinity()
+{
+	return -INFINITY;
+}
+
+MBool Double::isInfinite(double aDbl)
+{
+	return isinf(aDbl);
+}
+
+MBool Double::isNaN(double aDbl)
+{
+	return isnan(aDbl);
+}
+
+MBool Double::isNeg(double aDbl)
+{
+	return aDbl<0.0;
+}
+#else	/* pre INFINITY C environment */
+
 //A trick to handle IEEE floating point exceptions on FreeBSD - E.D.
 #ifdef __FreeBSD__
 #include <ieeefp.h>
@@ -127,9 +159,20 @@
 const PRUint32 negInfMask[2] = {0, TX_DOUBLE_HI32_EXPMASK | TX_DOUBLE_HI32_SIGNBIT};
 #endif
 
-const double Double::NaN = *((double*)nanMask);
-const double Double::POSITIVE_INFINITY = *((double*)infMask);
-const double Double::NEGATIVE_INFINITY = *((double*)negInfMask);
+double Double::NaN()
+{
+	return *((double*)nanMask);
+}
+
+double Double::PositiveInfinity()
+{
+	return *((double*)infMask);
+}
+
+double Double::NegativeInfinity()
+{
+	return *((double*)negInfMask);
+}
 
 /*
  * Determines whether the given double represents positive or negative
@@ -157,6 +200,7 @@
 {
     return (TX_DOUBLE_HI32(aDbl) & TX_DOUBLE_HI32_SIGNBIT) != 0;
 }
+#endif	/* C environment has INFINITY and NAN */
 
 /*
  * Converts the given String to a double, if the String value does not
@@ -244,7 +288,7 @@
     {
         if (mState == eIllegal || mBuffer.IsEmpty() ||
             (mBuffer.Length() == 1 && mBuffer[0] == '.')) {
-            return Double::NaN;
+            return Double::NaN();
         }
         return mSign*PR_strtod(mBuffer.get(), 0);
     }
