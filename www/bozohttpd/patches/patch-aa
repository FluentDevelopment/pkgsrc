$NetBSD: patch-aa,v 1.15 2004/06/21 01:45:22 lukem Exp $

--- bozohttpd.c.orig	2004-02-19 00:11:57.000000000 +1100
+++ bozohttpd.c
@@ -118,6 +118,9 @@
 #undef NO_SSL_SUPPORT		/* don't support ssl (https) */
 #endif
 
+/* XXXPKGSRC: change in sync with PKGREVISION */
+#define SERVER_SOFTWARE	"bozohttpd/20040218nb6"
+
 #ifndef INDEX_HTML
 #define INDEX_HTML	"index.html"
 #endif
@@ -136,6 +139,9 @@
 #ifndef REDIRECT_FILE
 #define REDIRECT_FILE	".bzredirect"
 #endif
+#ifndef ABSREDIRECT_FILE
+#define ABSREDIRECT_FILE	".bzabsredirect"
+#endif
 
 /*
  * And so it begins ..
@@ -329,7 +335,7 @@ static	void	process_request(http_req *);
 static	void	check_special_files(http_req *, const char *);
 static	int	check_direct_access(http_req *request);
 static	char	*transform_request(http_req *, int *);
-static	void	handle_redirect(http_req *, const char *);
+static	void	handle_redirect(http_req *, const char *, int absolute);
 static	void	print_header(http_req *, struct stat *, const char *,
 			     const char *);
 
@@ -1186,7 +1192,7 @@ process_request(request)
 	if (fstat(fd, &sb) < 0)
 		http_error(500, request, "can't fstat");
 	if (S_ISDIR(sb.st_mode))
-		handle_redirect(request, NULL);
+		handle_redirect(request, NULL, 0);
 		/* NOTREACHED */
 	/* XXX RFC1945 10.9 If-Modified-Since (http code 304) */
 
@@ -1346,9 +1352,8 @@ static void
 sigchild(signo)
 	int signo;
 {
-	int status;
 
-	while (waitpid(-1, &status, WNOHANG) != -1)
+	while (waitpid(-1, NULL, WNOHANG) > 0)
 		;
 }
 #endif /* NO_DAEMON_MODE */
@@ -1438,6 +1443,9 @@ check_special_files(http_req *request, c
 	if (strcmp(name, REDIRECT_FILE) == 0)
 		http_error(403, request,
 		    "no permission to open redirect file");
+	if (strcmp(name, ABSREDIRECT_FILE) == 0)
+		http_error(403, request,
+		    "no permission to open redirect file");
 #ifdef DO_HTPASSWD
 	if (strcmp(name, AUTH_FILE) == 0)
 		http_error(403, request,
@@ -1454,8 +1462,8 @@ check_bzredirect(http_req *request)
 {
 	struct stat sb;
 	char dir[MAXPATHLEN], redir[MAXPATHLEN], redirpath[MAXPATHLEN];
-	char *basename;
-	int rv;
+	char *basename, *finalredir;
+	int rv, absolute;
 
 
 	/*
@@ -1477,19 +1485,35 @@ check_bzredirect(http_req *request)
 	}
 
 	snprintf(redir, sizeof(redir), "%s/%s", dir, REDIRECT_FILE);
-	if (lstat(redir, &sb) < 0 || S_ISLNK(sb.st_mode) == 0)
-		return;
+	if (lstat(redir, &sb) == 0) {
+		if (S_ISLNK(sb.st_mode) == 0)
+			return;
+		absolute = 0;
+	} else {
+		snprintf(redir, sizeof(redir), "%s/%s", dir, ABSREDIRECT_FILE);
+		if (lstat(redir, &sb) < 0 || S_ISLNK(sb.st_mode) == 0)
+			return;
+		absolute = 1;
+	}
 	debug((DEBUG_FAT, "check_bzredirect: calling readlink"));
 	rv = readlink(redir, redirpath, sizeof redirpath);
-	if (rv == -1)
+	if (rv == -1) {
+		debug((DEBUG_FAT, "readlink failed"));
 		return;
+	}
 	if (rv - 1 < sizeof redirpath)
 		redirpath[rv] = '\0';
+	debug((DEBUG_FAT, "readlink returned \"%s\"", redirpath));
 	
 	/* now we have the link pointer, redirect to the real place */
-	snprintf(redir, sizeof(redir), "/%s/%s", dir, redirpath);
-	debug((DEBUG_FAT, "check_bzredirect: new redir %s", redir));
-	handle_redirect(request, redir);
+	if (absolute) {
+		finalredir = redirpath;
+	} else {
+		snprintf(redir, sizeof(redir), "/%s/%s", dir, redirpath);
+		finalredir = redir;
+	}
+	debug((DEBUG_FAT, "check_bzredirect: new redir %s", finalredir));
+	handle_redirect(request, finalredir, absolute);
 }
 
 /*
@@ -1602,7 +1626,7 @@ transform_request(request, isindex)
 			if (asprintf(&slashindexhtml, "/%s", index_html) < 0)
 				error(1, "asprintf");
 			debug((DEBUG_FAT, "rflag: redirecting %s to %s", url, slashindexhtml));
-			handle_redirect(request, slashindexhtml);
+			handle_redirect(request, slashindexhtml, 0);
 			/* NOTREACHED */
 		}
 	}
@@ -1619,7 +1643,7 @@ transform_request(request, isindex)
 		if (url[2] == '\0')
 			http_error(404, request, "missing username");
 		if (strchr(url + 2, '/') == NULL)
-			handle_redirect(request, NULL);
+			handle_redirect(request, NULL, 0);
 			/* NOTREACHED */
 		debug((DEBUG_FAT, "calling transform_user"));
 		return (transform_user(request, isindex));
@@ -1733,9 +1757,10 @@ transform_user(request, isindex)
  * do automatic redirection
  */
 static void
-handle_redirect(request, url)
+handle_redirect(request, url, absolute)
 	http_req *request;
 	const char *url;
+	int absolute;
 {
 	char *urlbuf;
 	char portbuf[20];
@@ -1755,16 +1780,24 @@ handle_redirect(request, url)
 	(void)bozoprintf("%s 301 Document Moved\r\n", request->hr_proto);
 	if (request->hr_proto != http_09) 
 		print_header(request, NULL, "text/html", NULL);
-	if (request->hr_proto != http_09)
-		(void)bozoprintf("Location: http://%s%s%s\r\n", myname, portbuf,
-		    url);
+	if (request->hr_proto != http_09) {
+		if (absolute) 
+			(void)bozoprintf("Location: http://%s\r\n", url);
+		else
+			(void)bozoprintf("Location: http://%s%s%s\r\n", myname, portbuf,
+			    url);
+	}
 	(void)bozoprintf("\r\n");
 	if (request->hr_method == HTTP_HEAD)
 		goto head;
 	(void)bozoprintf("<html><head><title>Document Moved</title></head>\n");
 	(void)bozoprintf("<body><h1>Document Moved</h1>\n");
-	(void)bozoprintf("This document had moved <a href=\"http://%s%s%s\">here</a>\n",
-	    myname, portbuf, url);
+	if (absolute) 
+		(void)bozoprintf("This document had moved <a href=\"http://%s\">here</a>\n",
+		    url);
+	else
+		(void)bozoprintf("This document had moved <a href=\"http://%s%s%s\">here</a>\n",
+		    myname, portbuf, url);
 	(void)bozoprintf("</body></html>\n");
 head:
 	fflush(stdout);
@@ -1951,6 +1984,7 @@ process_cgi(request)
 	spsetenv("SERVER_PROTOCOL", request->hr_proto, curenvp++);
 	spsetenv("REQUEST_METHOD", request->hr_methodstr, curenvp++);
 	spsetenv("SCRIPT_NAME", url, curenvp++);
+	spsetenv("SCRIPT_FILENAME", url+1, curenvp++);
 	spsetenv("SERVER_SOFTWARE", server_software, curenvp++);
 	spsetenv("REQUEST_URI", request->hr_url, curenvp++);
 	spsetenv("DATE_GMT", date, curenvp++);
@@ -1977,8 +2011,8 @@ process_cgi(request)
 
 	/* may as well wait as long as possible */
 print_cgi_header:
-	(void)bozoprintf("%s 200 Here it is\r\n", request->hr_proto);
 	if (!aflag) {
+		(void)bozoprintf("%s 200 Here it is\r\n", request->hr_proto);
 		debug((DEBUG_OBESE, "process_cgi:  writing HTTP header .."));
 		if (request->hr_proto != http_09)
 			print_header(NULL, NULL, NULL, NULL);
@@ -1988,8 +2022,6 @@ print_cgi_header:
 	} else
 		debug((DEBUG_OBESE, "process_cgi:  not-writing HTTP header .."));
 
-	/* XXX we should be printing 200 here? */
-	(void)bozoprintf("%s 200 Here it is\r\n", request->hr_proto);
 	debug((DEBUG_FAT, "process_cgi: going exec %s, %s %s %s",
 	    path, argv[0], strornull(argv[1]), strornull(argv[2])));
 
@@ -2078,7 +2110,7 @@ escape_html(request)
 	request->hr_url = tmp;
 }
 
-/* this fixes the %HH hack that RFC1738 requires.  */
+/* this fixes the %HH hack that RFC2396 requires.  */
 static void
 fix_url_percent(request)
 	http_req *request;
@@ -2089,19 +2121,7 @@ fix_url_percent(request)
 	url = request->hr_url;
 
 	/* make sure we don't translate *too* much */
-#ifndef NO_CGIBIN_SUPPORT
-	/*
-	 * XXX somewhat duplicate cgibin check here, but this one lets
-	 * and encoded "/cgi-bin" work, but not to stop everything past
-	 * the '?' being not fixed.
-	 *
-	 * XXX cgihandlers support
-	 */
-	if (cgibin && strncmp(url + 1, CGIBIN_PREFIX, CGIBIN_PREFIX_LEN) == 0) {
-		end = strchr(request->hr_url + CGIBIN_PREFIX_LEN, '?');
-	} else
-#endif /* NO_CGIBIN_SUPPORT */
-		end = 0;
+	end = strchr(request->hr_url, '?');
 
 	/* fast forward to the first % */
 	if ((s = strchr(url, '%')) == NULL)
@@ -2291,6 +2311,7 @@ static struct content_map content_map[] 
 	{ ".ppt",	"application/powerpoint",	"",		"", NULL },
 	{ ".rtf",	"application/rtf",		"",		"", NULL },
 	{ ".bcpio",	"application/x-bcpio",		"",		"", NULL },
+	{ ".torrent",	"application/x-bittorrent",	"",		"", NULL },
 	{ ".vcd",	"application/x-cdlink",		"",		"", NULL },
 	{ ".cpio",	"application/x-cpio",		"",		"", NULL },
 	{ ".csh",	"application/x-csh",		"",		"", NULL },
