$NetBSD: patch-ac,v 1.2 2002/10/27 06:47:45 rh Exp $

--- oss.c.orig	Tue May 15 07:35:52 2001
+++ oss.c
@@ -42,9 +42,10 @@
 #  include <sys/soundcard.h>
 #elif defined(HAVE_MACHINE_SOUNDCARD_H)
 #  include <machine/soundcard.h>
+#elif defined(HAVE_SOUNDCARD_H)
+#  include <soundcard.h>
 #endif
 
-
 /* output plugin callback prototypes */
 static void oss_get_volume      (int *l, int *r);
 static void oss_set_volume      (int l, int r);
@@ -305,9 +306,9 @@ oss_open_audio(AFormat fmt, int rate, in
   if(config->oss_use_alt_audio_device && (config->oss_alt_audio_device != NULL))
     device_name = g_strdup(config->oss_alt_audio_device);
   else if(config->oss_audio_device > 0)
-    device_name = g_strdup_printf("/dev/dsp%d", config->oss_audio_device);
+    device_name = g_strdup_printf(DEFAULT_OSS_ALT_AUDIO_DEVICE "%d", config->oss_audio_device);
   else
-    device_name = g_strdup("/dev/dsp");
+    device_name = g_strdup(DEFAULT_OSS_ALT_AUDIO_DEVICE);
 
   /* HACK: Test if the device is not locked by another process. This is
    *       just a crude workaround to avoid complete lockup of XMMS. It is
@@ -499,13 +500,26 @@ buffer_thread_f(void *arg)
   while(dsp_fd != -1) {
     /* wait for device */
     if(dsp_select_works) {
-      tv.tv_sec  = 0;
+      pthread_mutex_unlock(&buffer_mutex);
+#ifdef _PTH_PTHREAD_H_
+     { int i;
+
+     for (i=0; i<16; i++) { 
+      tv.tv_usec = OSS_FRAGMENT_UTIME/16;
+#else
       tv.tv_usec = OSS_FRAGMENT_UTIME;
+#endif
+      tv.tv_sec  = 0;
       FD_ZERO(&set);
       FD_SET(dsp_fd, &set);
 
-      pthread_mutex_unlock(&buffer_mutex);
       sel = select(dsp_fd+1, NULL, &set, NULL, &tv);
+#ifdef _PTH_PTHREAD_H_
+      if (sel) break;
+
+      sched_yield();
+     }}
+#endif
       pthread_mutex_lock(&buffer_mutex);
 
       if(sel == -1) {
