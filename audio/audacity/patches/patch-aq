$NetBSD: patch-aq,v 1.2 2002/10/04 08:59:37 jlam Exp $

--- snd/sndheader.c.orig	Wed Jun  5 00:51:19 2002
+++ snd/sndheader.c
@@ -52,8 +52,12 @@
 
 #endif
 
-#if defined(MAC) && !defined(__MACOSX__)
-typedef long int32_t;
+#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(LINUX) || defined(__MACOSX__)
+#  include <sys/types.h>
+#else
+typedef short		int16_t;
+typedef long		int32_t;
+typedef unsigned long	u_int32_t;
 #endif
 
 #ifndef min
@@ -75,16 +79,23 @@ typedef long int32_t;
 #define htonl(x) (x)
 #endif
 
+const union {
+	char c[12];
+	int32_t i[3];
+} sndmagic = {
+	".sndFORMRIFF"
+};
+
 /* AIFF file Marker declaration */
 typedef struct {
-    short id;
-    long position;
+    int16_t id;
+    int32_t position;
 } marker_node, *marker_type;
 
 /*  instrument definitions */
-typedef short marker_id;
+typedef int16_t marker_id;
 typedef struct {
-    short   play_mode;
+    int16_t play_mode;
     marker_id  begin_loop;
     marker_id  end_loop;
 } aiff_loop_node, *aiff_loop_type;
@@ -97,13 +108,13 @@ typedef struct {
     char	high_note;
     char	low_velocity;
     char	high_velocity;
-    short	gain;
+    int16_t	gain;
     aiff_loop_node	sustain_loop;
     aiff_loop_node	release_loop;
 } inst_node;
 
 
-long snd_read_header(snd_type snd, long *flags);
+int32_t snd_read_header(snd_type snd, long *flags);
 void snd_write_header(snd_type snd, long *flags);
 
 double read_ieee_extended(snd_type snd);
@@ -132,7 +143,7 @@ void resetfile(int file)
 																	   }
 
 
-char readchar(int file, long *read_in)
+char readchar(int file, int32_t *read_in)
 {
     char c = 0;
     readitem(file, &c, char);
@@ -140,23 +151,23 @@ char readchar(int file, long *read_in)
 }
 
 
-long readlong(int file, long *read_in)
+int32_t read32(int file, int32_t *read_in)
 {
-    long l = 0;
+    int32_t l = 0;
     readitem(file, &l, int32_t);
     return ntohl(l);
 }
 
 
-short readshort(int file, long *read_in)
+int16_t read16(int file, int32_t *read_in)
 { 
-    short s = 0;
-    readitem(file, &s, short);
+    int16_t s = 0;
+    readitem(file, &s, int16_t);
     return ntohs(s);
 }
 
 
-int32_t revlong(int32_t l)
+int32_t rev32(int32_t l)
 {
     return (((l >> 0) & 0xFF) << 24) |
 	(((l >> 8) & 0xFF) << 16) |
@@ -165,32 +176,32 @@ int32_t revlong(int32_t l)
 }
 
 
-long readrevlong(int file, long *read_in)
+int32_t readrev32(int file, int32_t *read_in)
 {
-    return revlong(readlong(file, read_in));
+    return rev32(read32(file, read_in));
 }
 
 
-short revshort(short s)
+int16_t rev16(int16_t s)
 {
     return ((s & 0xFF) << 8) | ((s >> 8) & 0xFF);
 }
 
 
-short readrevshort(int file, long *read_in)
+int16_t readrev16(int file, int32_t *read_in)
 {
-    return revshort(readshort(file, read_in));
+    return rev16(read16(file, read_in));
 }
 
 
-float readfloat(int file, long *read_in)
+float readfloat(int file, int32_t *read_in)
 {
     float f = 0.0F;
     readitem(file, &f, float);
     return f;
 }
 
-unsigned char readuchar(int file, long *read_in)
+unsigned char readuchar(int file, int32_t *read_in)
 {
     unsigned char c = 0;
     readitem(file, &c, unsigned char);
@@ -204,27 +215,27 @@ unsigned char readuchar(int file, long *
 #define writeitem(F,L,T) snd_file_write(F, (char *) L, sizeof(T));
 
 
-void writelong(int file, int32_t l)
+void write32(int file, int32_t l)
 {
     l = htonl(l);
     writeitem(file, &l, int32_t);
 }
 
-void writeshort(int file, short s)
+void write16(int file, int16_t s)
 {
     s = htons(s);
-    writeitem(file, &s, short);
+    writeitem(file, &s, int16_t);
 }
 
-void writerevlong(int file, long l)
+void writerev32(int file, int32_t l)
 {
-    writelong(file, revlong(l));
+    write32(file, rev32(l));
 }
 
 
-void writerevshort(int file, short s)
+void writerev16(int file, int16_t s)
 {
-    writeshort(file, revshort(s));
+    write16(file, rev16(s));
 }
 
 
@@ -344,9 +355,9 @@ int snd_open_file(snd_type snd, long *fl
 
 int snd_seek(snd_type snd, double skip)
 {
-    long offset_in_bytes = ((long) (skip * snd->format.srate + 0.5)) *
+    int32_t offset_in_bytes = ((int32_t) (skip * snd->format.srate + 0.5)) *
 	snd_bytes_per_frame(snd);
-    long new_offset = snd->u.file.byte_offset + offset_in_bytes;
+    int32_t new_offset = snd->u.file.byte_offset + offset_in_bytes;
     
     if (new_offset > snd->u.file.end_offset) return !SND_SUCCESS;
     snd->u.file.byte_offset = new_offset;
@@ -356,11 +367,11 @@ int snd_seek(snd_type snd, double skip)
     return SND_SUCCESS;
 }
 
-void readloop(aiff_loop_type loop, int file, long *read_in)
+void readloop(aiff_loop_type loop, int file, int32_t *read_in)
 {
-    loop->play_mode = readshort(file, read_in);
-    loop->begin_loop = readshort(file, read_in);
-    loop->end_loop = readshort(file, read_in);
+    loop->play_mode = read16(file, read_in);
+    loop->begin_loop = read16(file, read_in);
+    loop->end_loop = read16(file, read_in);
 }
 
 
@@ -393,44 +404,44 @@ static double StepToHz(double step) 
 #define AIFF_SND_MAGIC (*((int32_t *) "FORM"))
 #define WAVE_SND_MAGIC (*((int32_t *) "RIFF"))
 
-long snd_read_header(snd_type snd, long *flags)
+int32_t snd_read_header(snd_type snd, long *flags)
 {
-    long read_in = 0;
-    long magic, bytemode, len;
-    short type=IRCAM_SND_COMMENT, size=0, encoding;
+    int32_t read_in = 0;
+    int32_t magic, bytemode, len;
+    int16_t type=IRCAM_SND_COMMENT, size=0, encoding;
     unsigned char buf[SIZEOF_IRCAM_HEADER];
     
     snd->u.file.loop_info = FALSE;
     len = snd_file_len(snd->u.file.file);  /* get length of file */
-    magic = readlong(snd->u.file.file, &read_in);
-    magic = htonl(magic);   /* undo what readlong did */
+    magic = read32(snd->u.file.file, &read_in);
+    magic = htonl(magic);   /* undo what read32 did */
     if (magic == IRCAM_SND_MAGIC) {
 	snd->u.file.header = SND_HEAD_IRCAM;
 	snd->format.srate = (double) readfloat(snd->u.file.file, &read_in);
-	snd->format.channels = readlong(snd->u.file.file, &read_in);
-	bytemode = readlong(snd->u.file.file, &read_in);
+	snd->format.channels = read32(snd->u.file.file, &read_in);
+	bytemode = read32(snd->u.file.file, &read_in);
 	(*flags) |= SND_HEAD_SRATE | SND_HEAD_CHANNELS;
 	/* now SF_ULAW, SF_SHORT, SF_FLOAT,AE_CHAR, AE_ALAW, AE_ULAW, AE_SHORT, AE_LONG, AE_FLOAT or other */
 	while (type != IRCAM_SND_END && type != IRCAM_SND_AUDIOENCODE) {
-	    type = readshort(snd->u.file.file, &read_in);
-	    size = readshort(snd->u.file.file, &read_in);
-	    if (size > 2 * sizeof(short)) {
+	    type = read16(snd->u.file.file, &read_in);
+	    size = read16(snd->u.file.file, &read_in);
+	    if (size > 2 * sizeof(int16_t)) {
 		int rc;
 		/* make sure we don't overflow buffer */
 		if (size < SIZEOF_IRCAM_HEADER) {
-		    rc = snd_file_read(snd->u.file.file, (char *) buf, (size - 2 * sizeof(short)));
+		    rc = snd_file_read(snd->u.file.file, (char *) buf, (size - 2 * sizeof(int16_t)));
 		} else {
 		    rc = 0; /* force error */
 		}
-		if (rc != (size - 2 * (int) sizeof(short))) {
+		if (rc != (size - 2 * (int) sizeof(int16_t))) {
 		    return fail(snd, "bad IRCAM header");
 		}
-		read_in += size - 2 * sizeof(short);
+		read_in += size - 2 * sizeof(int16_t);
 	    }
 	}
 	if (type == IRCAM_SND_AUDIOENCODE) {
 	    /* printf("Got IRCAM sound format\n"); */
-	    encoding = *((short *)(buf));
+	    encoding = *((int16_t *)(buf));
 	    (*flags) |= SND_HEAD_MODE | SND_HEAD_BITS;
 	    switch (encoding) {
 	      case IRCAM_SND_CHAR:
@@ -469,7 +480,7 @@ long snd_read_header(snd_type snd, long 
 		(*flags) |= SND_HEAD_MODE;
 		snd->format.mode = SND_MODE_ULAW;
 		break;
-	      case sizeof(short):
+	      case sizeof(int16_t):
 		snd->format.mode = SND_MODE_PCM;
 		break;
 	      case sizeof(float):
@@ -487,13 +498,13 @@ long snd_read_header(snd_type snd, long 
 	snd->u.file.current_offset = snd->u.file.byte_offset;
 	
     } else if (magic == NEXT_SND_MAGIC) {
-	long hdr_size, trash, rate;
+	int32_t hdr_size, trash, rate;
 	snd->u.file.header = SND_HEAD_NEXT;
-	hdr_size = readlong(snd->u.file.file, &read_in);	/* dataLocation */
-	trash = readlong(snd->u.file.file, &read_in); 	/* dataSize */
-	bytemode = readlong(snd->u.file.file, &read_in);	/* dataFormat */
-	rate = readlong(snd->u.file.file, &read_in);		/* samplingRate */
-	snd->format.channels = readlong(snd->u.file.file, &read_in);	/* channelCount */
+	hdr_size = read32(snd->u.file.file, &read_in);	/* dataLocation */
+	trash = read32(snd->u.file.file, &read_in); 	/* dataSize */
+	bytemode = read32(snd->u.file.file, &read_in);	/* dataFormat */
+	rate = read32(snd->u.file.file, &read_in);		/* samplingRate */
+	snd->format.channels = read32(snd->u.file.file, &read_in);	/* channelCount */
 	
 	snd->format.srate = (double) rate;
 	(*flags) = SND_HEAD_SRATE | SND_HEAD_CHANNELS;
@@ -565,20 +576,20 @@ long snd_read_header(snd_type snd, long 
 	}
 	snd->u.file.byte_offset = read_in;
     } else if (magic == AIFF_SND_MAGIC) {
-	unsigned long totalsize;
-	unsigned long ssnd_start = 0;
+	u_int32_t totalsize;
+	u_int32_t ssnd_start = 0;
 	char buf[4];
-	long blocksize;
-	long offset;
-	long chunksize;
-	long ssnd_chunksize;
+	int32_t blocksize;
+	int32_t offset;
+	int32_t chunksize;
+	int32_t ssnd_chunksize;
 	inst_node inst;
-	short nmarkers;
+	int16_t nmarkers;
 	marker_type markers = NULL;
 	int inst_read = FALSE;
 	
 	snd->u.file.header = SND_HEAD_AIFF;
-	totalsize = (unsigned long) readlong(snd->u.file.file, &read_in);
+	totalsize = (u_int32_t) read32(snd->u.file.file, &read_in);
 	if (snd_file_read(snd->u.file.file, buf, 4) != 4 || strncmp(buf, "AIFF", 4) != 0) {
 	    return fail(snd, 
 			"AIFF 'FORM' chunk does not specify 'AIFF' as type\n");
@@ -602,15 +613,15 @@ long snd_read_header(snd_type snd, long 
 #endif
 	    if (strncmp(buf, "COMM", 4) == 0) {
 		/* COMM chunk */
-		long chunksize;
-		long frames;
-		chunksize = readlong(snd->u.file.file, &read_in);
+		int32_t chunksize;
+		int32_t frames;
+		chunksize = read32(snd->u.file.file, &read_in);
 		if (chunksize != 18) {
 		    return fail(snd, "AIFF COMM chunk has bad size\n");
 		}
-		snd->format.channels = (long) readshort(snd->u.file.file, &read_in);
-		frames = readlong(snd->u.file.file, &read_in);
-		snd->format.bits = readshort(snd->u.file.file, &read_in);
+		snd->format.channels = (int32_t) read16(snd->u.file.file, &read_in);
+		frames = read32(snd->u.file.file, &read_in);
+		snd->format.bits = read16(snd->u.file.file, &read_in);
 		snd->format.mode = SND_MODE_PCM;
 		snd->format.srate = read_ieee_extended(snd);
 		snd->u.file.end_offset = frames * snd_bytes_per_frame(snd) +
@@ -619,9 +630,9 @@ long snd_read_header(snd_type snd, long 
 		    SND_HEAD_CHANNELS | SND_HEAD_LEN;
 	    } else if (strncmp(buf, "SSND", 4) == 0) {
 		/* SSND chunk */
-		ssnd_chunksize = readlong(snd->u.file.file, &read_in);
-		offset = readlong(snd->u.file.file, &read_in);
-		blocksize = readlong(snd->u.file.file, &read_in);
+		ssnd_chunksize = read32(snd->u.file.file, &read_in);
+		offset = read32(snd->u.file.file, &read_in);
+		blocksize = read32(snd->u.file.file, &read_in);
 		/* remember the file offset, there may be more chunks */
 		ssnd_start = snd_file_lseek(snd->u.file.file, 0, SND_SEEK_CUR);
 		chunksize = ssnd_chunksize;
@@ -630,31 +641,31 @@ long snd_read_header(snd_type snd, long 
 		snd_file_lseek(snd->u.file.file, chunksize - 8, SND_SEEK_CUR);
 		read_in += chunksize - 8;
 	    } else if (strncmp(buf, "MARK", 4) == 0) {
-		long chunksize = readlong(snd->u.file.file, &read_in);
+		int32_t chunksize = read32(snd->u.file.file, &read_in);
 		int i;
 		
-		nmarkers = readshort(snd->u.file.file, &read_in);
+		nmarkers = read16(snd->u.file.file, &read_in);
 		markers = (marker_type) snd_alloc(nmarkers * sizeof(marker_node));
 		for (i = 0; i < nmarkers; i++) {
 		    unsigned char label[256];
 		    int len;
-		    markers[i].id = readshort(snd->u.file.file, &read_in);
-		    markers[i].position = readlong(snd->u.file.file, &read_in);
-		    if (snd_file_read(snd->u.file.file, (char *)label, (long)1) != 1) 
+		    markers[i].id = read16(snd->u.file.file, &read_in);
+		    markers[i].position = read32(snd->u.file.file, &read_in);
+		    if (snd_file_read(snd->u.file.file, (char *)label, (int32_t)1) != 1) 
 			return fail(snd, "problem reading AIFF file\n");
 		    len = label[0] | 1;
-		    if (snd_file_read(snd->u.file.file, (char *)label, (long)len) != len)
+		    if (snd_file_read(snd->u.file.file, (char *)label, (int32_t)len) != len)
 			return fail(snd, "problam reading AIFF file\n");
 		}
 	    } else if (strncmp(buf, "INST", 4) == 0) {
-		chunksize = readlong(snd->u.file.file, &read_in);
+		chunksize = read32(snd->u.file.file, &read_in);
 		inst.base_note = readchar(snd->u.file.file, &read_in);
 		inst.detune = readchar(snd->u.file.file, &read_in);
 		inst.low_note = readchar(snd->u.file.file, &read_in);
 		inst.high_note = readchar(snd->u.file.file, &read_in);
 		inst.low_velocity = readchar(snd->u.file.file, &read_in);
 		inst.high_velocity = readchar(snd->u.file.file, &read_in);
-		inst.gain = readshort(snd->u.file.file, &read_in);
+		inst.gain = read16(snd->u.file.file, &read_in);
 		readloop(&inst.sustain_loop, snd->u.file.file, &read_in);
 		readloop(&inst.release_loop, snd->u.file.file, &read_in);
 		
@@ -673,7 +684,7 @@ long snd_read_header(snd_type snd, long 
 		snd->u.file.high_velocity = inst.high_velocity;
 		inst_read = TRUE;
 	    } else {
-		long chunksize = readlong(snd->u.file.file, &read_in);
+		int32_t chunksize = read32(snd->u.file.file, &read_in);
 		if (chunksize & 1) chunksize ++;  /* round up to even number */
 		read_in += chunksize;
 		/* skip the chunk */
@@ -722,13 +733,13 @@ long snd_read_header(snd_type snd, long 
 	snd->u.file.current_offset = snd->u.file.byte_offset;
 	snd->u.file.end_offset = snd->u.file.byte_offset + ssnd_chunksize - 8;
     } else if (magic == WAVE_SND_MAGIC) {
-	long size;
+	int32_t size;
 	char buf[4];
-	short format;
+	int16_t format;
 	
 	snd->u.file.header = SND_HEAD_WAVE;
 	/* RIFF WAVE uses little-endian format -- be careful! */
-	size = readrevlong(snd->u.file.file, &read_in);
+	size = readrev32(snd->u.file.file, &read_in);
 	if (snd_file_read(snd->u.file.file, buf,  4) != 4 || strncmp(buf, "WAVE", 4) != 0) {
 	    return fail(snd, 
 			"RIFF file does not specify 'WAVE' as type\n");
@@ -736,19 +747,19 @@ long snd_read_header(snd_type snd, long 
 	
 	/* Skip to the next "fmt " or end of file */
 	while (1) {
-	    long siz;
+	    int32_t siz;
 	    if (snd_file_read(snd->u.file.file, buf, 4) != 4) {
 		return fail(snd, "WAVE file missing fmt spec");
 	    }
 	    if (strncmp("fmt ", buf, 4) == 0) break;
-	    siz = readrevlong(snd->u.file.file, &read_in);
+	    siz = readrev32(snd->u.file.file, &read_in);
 	    while (siz > 0) {
 		snd_file_read(snd->u.file.file, buf, 1);
 		siz--;
 	    }
 	}
-	size = readrevlong(snd->u.file.file, &read_in);
-	format = readrevshort(snd->u.file.file, &read_in);
+	size = readrev32(snd->u.file.file, &read_in);
+	format = readrev16(snd->u.file.file, &read_in);
 	switch (format) {
 	  case WAVE_FORMAT_UNKNOWN:
 	    return fail(snd, "file in Microsoft Official Unknown format");
@@ -775,11 +786,11 @@ long snd_read_header(snd_type snd, long 
 	  default:
 	    return fail(snd, "file in unknown format");
 	}	
-	snd->format.channels = readrevshort(snd->u.file.file, &read_in);
-	snd->format.srate = (double) readrevlong(snd->u.file.file, &read_in);
-	readrevlong(snd->u.file.file, &read_in);  /* Average bytes/second */
-	readrevshort(snd->u.file.file, &read_in); /* Block align */
-	snd->format.bits = readrevshort(snd->u.file.file, &read_in);
+	snd->format.channels = readrev16(snd->u.file.file, &read_in);
+	snd->format.srate = (double) readrev32(snd->u.file.file, &read_in);
+	readrev32(snd->u.file.file, &read_in);  /* Average bytes/second */
+	readrev16(snd->u.file.file, &read_in); /* Block align */
+	snd->format.bits = readrev16(snd->u.file.file, &read_in);
 	snd->format.mode = SND_MODE_PCM;
 	if (snd->format.bits == 8) snd->format.mode = SND_MODE_UPCM;	/* unsigned */
 	*flags = SND_HEAD_MODE | SND_HEAD_BITS | SND_HEAD_SRATE |
@@ -791,19 +802,19 @@ long snd_read_header(snd_type snd, long 
 	    snd_file_lseek(snd->u.file.file, size - 16, SND_SEEK_CUR);
 	/* skip over any other forms until you find "data" */
 	while (1) {
-	    long n = snd_file_read(snd->u.file.file, buf, 4);
+	    int32_t n = snd_file_read(snd->u.file.file, buf, 4);
 	    if (n != 4) {
 		return fail(snd, "missing data portion");
 	    }
 	    if (strncmp("data", buf, 4) == 0) break;
-	    n = readrevlong(snd->u.file.file, &read_in);    /* length of form */
+	    n = readrev32(snd->u.file.file, &read_in);    /* length of form */
 	    snd->u.file.byte_offset = 
           snd_file_lseek(snd->u.file.file, n, SND_SEEK_CUR);
 	}
 	snd->u.file.byte_offset += 8; /* "data" and length use 8 bytes */
 	snd->u.file.current_offset = snd->u.file.byte_offset;
 	snd->u.file.end_offset = snd->u.file.byte_offset + 
-	    readrevlong(snd->u.file.file, &read_in);
+	    readrev32(snd->u.file.file, &read_in);
     } else {
 	snd->u.file.header = SND_HEAD_NONE;
 	(*flags) = 0;
@@ -825,15 +836,15 @@ long snd_read_header(snd_type snd, long 
 
 /* write_zeros -- add zeros to end of file */
 /**/
-void write_zeros(int fout, long n)
+void write_zeros(int fout, int32_t n)
 {
-    long zero = 0;
+    int32_t zero = 0;
     while (n > 0) {
 	/* don't put min() in the arg list of write on an RS6K */
 	/* there seems to be a compiler bug */
-	long len = min(n, sizeof(long));
+	int32_t len = min(n, sizeof(int32_t));
 	snd_file_write(fout, (char *) &zero, len);
-	n -= sizeof(long);
+	n -= sizeof(int32_t);
     }
 }
 
@@ -844,17 +855,17 @@ void write_zeros(int fout, long n)
  * SIZEOF_IRCAM_HEADER, but in the case of the hybrid CMIX headers, length
  * will be shorter to accommodate the NeXT header prefix
  */
-void write_ircam_start(snd_type snd, long length)
+void write_ircam_start(snd_type snd, int32_t length)
 {
-    short encoding;
+    int16_t encoding;
     
-    writelong(snd->u.file.file, IRCAM_SND_MAGIC);
+    write32(snd->u.file.file, IRCAM_SND_MAGIC);
     writefloat(snd->u.file.file, (float) snd->format.srate);
-    writelong(snd->u.file.file, snd->format.channels);
-    writelong(snd->u.file.file, snd->format.bits >> 3);
+    write32(snd->u.file.file, snd->format.channels);
+    write32(snd->u.file.file, snd->format.bits >> 3);
     /* now write the "CODE" section */
-    writeshort(snd->u.file.file, IRCAM_SND_AUDIOENCODE);
-    writeshort(snd->u.file.file, 3 * sizeof(short));    /* size of this record */
+    write16(snd->u.file.file, IRCAM_SND_AUDIOENCODE);
+    write16(snd->u.file.file, 3 * sizeof(int16_t));    /* size of this record */
     if (snd->format.bits == 8) {
 	encoding = IRCAM_SND_CHAR;
 	if (snd->format.mode == SND_MODE_ULAW) encoding = IRCAM_SND_ULAW;
@@ -867,11 +878,11 @@ void write_ircam_start(snd_type snd, lon
 	encoding = IRCAM_SND_FLOAT;
 	if (snd->format.mode == SND_MODE_PCM) encoding = IRCAM_SND_LONG;
     }
-    writeshort(snd->u.file.file, encoding);
+    write16(snd->u.file.file, encoding);
     
     /* end the "CODE" section */
-    writeshort(snd->u.file.file, IRCAM_SND_END);
-    writeshort(snd->u.file.file, 2 * sizeof(short));
+    write16(snd->u.file.file, IRCAM_SND_END);
+    write16(snd->u.file.file, 2 * sizeof(int16_t));
     
     /* write filler */
     length -= ( 16 /* head */ + 6 /* AudioEncode */ + 4 /* End */ );
@@ -885,14 +896,14 @@ void write_ircam_start(snd_type snd, lon
  * Note: uses length for Length field, but does not fill with zeros.
  * Instead, this routine writes only the NeXT 24 byte header.
  */
-void write_next_start(snd_type snd, long length)
+void write_next_start(snd_type snd, int32_t length)
 {
-    short encoding;
+    int16_t encoding;
     
-    writelong(snd->u.file.file, NEXT_SND_MAGIC);
+    write32(snd->u.file.file, NEXT_SND_MAGIC);
     /* header size matches cmix's bsd format */
-    writelong(snd->u.file.file, length);
-    writelong(snd->u.file.file, 0); /* data size, 0 -> unspecified */
+    write32(snd->u.file.file, length);
+    write32(snd->u.file.file, 0); /* data size, 0 -> unspecified */
     if (snd->format.bits == 8) {
 	encoding = NEXT_SND_FORMAT_LINEAR_8;
 	if (snd->format.mode == SND_MODE_ULAW)
@@ -907,9 +918,9 @@ void write_next_start(snd_type snd, long
 	if (snd->format.mode == SND_MODE_PCM)
 	    encoding = NEXT_SND_FORMAT_LINEAR_32;
     }
-    writelong(snd->u.file.file, encoding);
-    writelong(snd->u.file.file, (long) (snd->format.srate + 0.5));
-    writelong(snd->u.file.file, snd->format.channels);
+    write32(snd->u.file.file, encoding);
+    write32(snd->u.file.file, (int32_t) (snd->format.srate + 0.5));
+    write32(snd->u.file.file, snd->format.channels);
 }
 
 
@@ -917,8 +928,8 @@ void write_next_start(snd_type snd, long
 /**/
 void snd_write_header(snd_type snd, long *flags)
 {
-    long nframes = 0x7f000000;
-    long bytes_per_frame = snd_bytes_per_frame(snd);
+    int32_t nframes = 0x7f000000;
+    int32_t bytes_per_frame = snd_bytes_per_frame(snd);
     
     /* end_offset will keep track of how much data written so far */
     snd->u.file.end_offset = 0;
@@ -939,23 +950,23 @@ void snd_write_header(snd_type snd, long
 	}
 	snd_file_write(snd->u.file.file, "FORM", 4); /* IFF header */
 	/* (bogus) file size: */
-	writelong(snd->u.file.file, 
+	write32(snd->u.file.file, 
 		  hsize + nframes * bytes_per_frame);
 	snd_file_write(snd->u.file.file, "AIFF", 4); /* File type */
 	
 	/* COMM chunk -- describes encoding (and #frames) */
 	snd_file_write(snd->u.file.file, "COMM", 4);
-	writelong(snd->u.file.file, 18); /* COMM chunk size */
-	writeshort(snd->u.file.file, (short) snd->format.channels); /* nchannels */
-	writelong(snd->u.file.file, nframes); /* number of frames */
-	writeshort(snd->u.file.file, (short) snd->format.bits); /* sample width, in bits */
+	write32(snd->u.file.file, 18); /* COMM chunk size */
+	write16(snd->u.file.file, (int16_t) snd->format.channels); /* nchannels */
+	write32(snd->u.file.file, nframes); /* number of frames */
+	write16(snd->u.file.file, (int16_t) snd->format.bits); /* sample width, in bits */
 	write_ieee_extended(snd->u.file.file, snd->format.srate);
 	/* SSND chunk -- describes data */
 	snd_file_write(snd->u.file.file, "SSND", 4);
-	writelong(snd->u.file.file, 
+	write32(snd->u.file.file, 
 		  8 + nframes * bytes_per_frame); /* chunk size */
-	writelong(snd->u.file.file, 0); /* offset */
-	writelong(snd->u.file.file, 0); /* block size */
+	write32(snd->u.file.file, 0); /* offset */
+	write32(snd->u.file.file, 0); /* block size */
 	snd->u.file.byte_offset = hsize;
 	/*	printf("snd_write_header AIFF, byte_offset = %ld\n",
 		snd_lseek(snd->u.file.file, (off_t) 0, SND_SEEK_CUR)); */
@@ -974,39 +985,39 @@ void snd_write_header(snd_type snd, long
 	break;
       case SND_HEAD_WAVE:
 	snd_file_write(snd->u.file.file, "RIFF", 4);
-	writerevlong(snd->u.file.file, 12+18+8 + nframes * bytes_per_frame);
+	writerev32(snd->u.file.file, 12+18+8 + nframes * bytes_per_frame);
 	snd_file_write(snd->u.file.file, "WAVE", 4);
 	snd_file_write(snd->u.file.file, "fmt ", 4);
-	writerevlong(snd->u.file.file, 18L);
+	writerev32(snd->u.file.file, 18L);
 	switch (snd->format.mode) /* Format type */
 	{
 	    case SND_MODE_ADPCM:
-		writerevshort(snd->u.file.file, 2);
+		writerev16(snd->u.file.file, 2);
 		break;
 	    case SND_MODE_PCM:
 	    case SND_MODE_UPCM:
-		writerevshort(snd->u.file.file, 1);
+		writerev16(snd->u.file.file, 1);
 		break;
 	    case SND_MODE_ULAW:
-		writerevshort(snd->u.file.file, 7);
+		writerev16(snd->u.file.file, 7);
 		break;
 	    case SND_MODE_ALAW:
-		writerevshort(snd->u.file.file, 6);
+		writerev16(snd->u.file.file, 6);
 		break;
 	    case SND_MODE_UNKNOWN:
 	    case SND_MODE_FLOAT:
 	    default:
-		writerevshort(snd->u.file.file, 0);
+		writerev16(snd->u.file.file, 0);
 		break;
 	}
-	writerevshort(snd->u.file.file, (short) snd->format.channels); /* Number of channels */
-	writerevlong(snd->u.file.file, (long) (snd->format.srate + 0.5)); /* Samples per second */
-	writerevlong(snd->u.file.file,  (((long) snd->format.srate) * bytes_per_frame)); /* Bytes per second*/
-	writerevshort(snd->u.file.file, (short) bytes_per_frame); /* Block alignment */
-	writerevshort(snd->u.file.file, (short) snd->format.bits); /* Bits per sample */
-	writerevshort(snd->u.file.file, (short) 0); /* Size of needed extra data */
+	writerev16(snd->u.file.file, (int16_t) snd->format.channels); /* Number of channels */
+	writerev32(snd->u.file.file, (int32_t) (snd->format.srate + 0.5)); /* Samples per second */
+	writerev32(snd->u.file.file,  (((int32_t) snd->format.srate) * bytes_per_frame)); /* Bytes per second*/
+	writerev16(snd->u.file.file, (int16_t) bytes_per_frame); /* Block alignment */
+	writerev16(snd->u.file.file, (int16_t) snd->format.bits); /* Bits per sample */
+	writerev16(snd->u.file.file, (int16_t) 0); /* Size of needed extra data */
 	snd_file_write(snd->u.file.file, "data", 4);
-	writerevlong(snd->u.file.file, (long) (nframes * bytes_per_frame));
+	writerev32(snd->u.file.file, (int32_t) (nframes * bytes_per_frame));
 	snd->u.file.byte_offset = 46;
 	break;
       default:
@@ -1018,7 +1029,7 @@ void snd_write_header(snd_type snd, long
 
 void write_sndheader_finish(snd_type snd)
 {
-    long n;
+    int32_t n;
     switch (snd->u.file.header) {
       case SND_HEAD_NONE:
 	break;
@@ -1039,20 +1050,20 @@ void write_sndheader_finish(snd_type snd
 	}
 	/* write filesize in the header */
 	snd_file_lseek(snd->u.file.file, 4, SND_SEEK_SET);
-	writelong(snd->u.file.file, n - 8 /* 'FORM'+size do not count */);
+	write32(snd->u.file.file, n - 8 /* 'FORM'+size do not count */);
 	
 	/* write number of frames in COMM chunk */
 	snd_file_lseek(snd->u.file.file, (4 /* 'AIFF' */ + 4 /* 'COMM' */ + 
 					 4 /* size */ + 2 /* channels */), 
 	      SND_SEEK_CUR);
-	writelong(snd->u.file.file, 
+	write32(snd->u.file.file, 
 		  (n - (hsize + 8)) / snd_bytes_per_frame(snd));
 	
 	/* write size in SSND chunk */
 	snd_file_lseek(snd->u.file.file, (2 /* snd->format.bits */ + 
 					 10 /* sr */ + 4 /* 'SSND' */), 
 	      SND_SEEK_CUR);
-	writelong(snd->u.file.file, 8 + datasize); /* chunk size */
+	write32(snd->u.file.file, 8 + datasize); /* chunk size */
 	break; }
       case SND_HEAD_IRCAM:
 	break;
@@ -1063,9 +1074,9 @@ void write_sndheader_finish(snd_type snd
 	n = snd_file_lseek(snd->u.file.file, 0, SND_SEEK_CUR);
 	/* back to the top */
 	snd_file_lseek(snd->u.file.file, 4, SND_SEEK_SET);
-	writerevlong(snd->u.file.file, n - 8);	/* file size - ['RIFF', len] */
+	writerev32(snd->u.file.file, n - 8);	/* file size - ['RIFF', len] */
 	snd_file_lseek(snd->u.file.file, 42, SND_SEEK_SET);
-	writerevlong(snd->u.file.file, n - 46); /* data size */
+	writerev32(snd->u.file.file, n - 46); /* data size */
 	break;
       default:
 	break;
@@ -1076,7 +1087,7 @@ void write_sndheader_finish(snd_type snd
 double read_ieee_extended(snd_type snd)
 {
     unsigned char buf[10];
-    if (snd_file_read(snd->u.file.file, (char *)buf, (long)10) != 10)
+    if (snd_file_read(snd->u.file.file, (char *)buf, (int32_t)10) != 10)
 	fail(snd, "EOF while reading IEEE extended number");
     return ConvertFromIeeeExtended(buf);
 }
@@ -1099,7 +1110,7 @@ void write_ieee_extended(int file, doubl
 
 char *mode_string[] = { "ADPCM", "PCM", "ULAW", "ALAW", "Float", "UPCM", "Unknown" };
 
-char *mode_to_string(long mode)
+char *mode_to_string(int32_t mode)
 {
     if (mode < 0 || mode >= SND_NUM_MODES) return "InvalidData";
     else return mode_string[mode];
