$NetBSD: patch-cf,v 1.3 2002/03/04 14:45:14 itohy Exp $

--- interface/scan_devices.c.orig	Mon Mar 26 14:44:01 2001
+++ interface/scan_devices.c	Mon Mar  4 00:23:01 2002
@@ -19,6 +19,8 @@
 #include "common_interface.h"
 #include "utils.h"
 
+#ifdef __linux__
+
 #define MAX_DEV_LEN 20 /* Safe because strings only come from below */
 /* must be absolute paths! */
 static char *scsi_cdrom_prefixes[]={
@@ -49,10 +51,12 @@
   "/dev/cm206cd",
   "/dev/gscd",
   "/dev/optcd",NULL};
+#endif
 
 /* Functions here look for a cdrom drive; full init of a drive type
    happens in interface.c */
 
+#ifdef __linux__
 cdrom_drive *cdda_find_a_cdrom(int messagedest,char **messages){
   /* Brute force... */
   
@@ -98,6 +102,16 @@
   }
   return(NULL);
 }
+#endif	/* __linux__ */
+
+#ifdef __NetBSD__
+
+cdrom_drive *cdda_find_a_cdrom(int messagedest,char **messages)
+{
+  errx(1, "cdda_find_a_cdrom: not implemented");
+  /* NOTREACHED */
+}
+#endif	/* __NetBSD__ */
 
 cdrom_drive *cdda_identify(const char *device, int messagedest,char **messages){
   struct stat st;
@@ -146,6 +160,7 @@
 cdrom_drive *cdda_identify_cooked(const char *dev, int messagedest,
 				  char **messages){
 
+#ifdef __linux__
   cdrom_drive *d=NULL;
   struct stat st;
   int fd=-1;
@@ -273,6 +288,12 @@
   idmessage(messagedest,messages,"\t\tCDROM sensed: %s\n",description);
   
   return(d);
+#endif
+
+#ifdef __NetBSD__
+  /* no kernel support for CD-DA */
+  return NULL;
+#endif
 }
 
 struct  sg_id {
@@ -289,12 +310,18 @@
 /* Even *this* isn't as simple as it bloody well should be :-P */
 /* SG has an easy interface, but SCSI overall does not */
 static int get_scsi_id(int fd, scsiid *id){
+#ifdef __linux__
   struct sg_id argid;
+#endif
+#ifdef __NetBSD__
+  struct scsi_addr argid;
+#endif
   int busarg;
 
   /* get the host/id/lun */
 
   if(fd==-1)return(-1);
+#ifdef __linux__
   if(ioctl(fd,SCSI_IOCTL_GET_IDLUN,&argid))return(-1);
   id->bus=argid.l2; /* for now */
   id->id=argid.l1&0xff;
@@ -302,6 +329,13 @@
 
   if(ioctl(fd,SCSI_IOCTL_GET_BUS_NUMBER,&busarg)==0)
     id->bus=busarg;
+#endif
+#ifdef __NetBSD__
+  if(ioctl(fd,SCIOCIDENTIFY,&argid))return(-1);
+  id->bus=argid.addr.scsi.scbus;
+  id->id=argid.addr.scsi.target;
+  id->lun=argid.addr.scsi.lun;
+#endif
   
   return(0);
 }
@@ -401,6 +435,7 @@
   strcat(a," ");
 }
 
+#ifdef __linux__
 /* At this point, we're going to punt compatability before SG2, and
    allow only SG2 and SG3 */
 static int verify_SG_version(cdrom_drive *d,int messagedest,
@@ -430,6 +465,7 @@
   idmessage(messagedest,messages,buffer,"");
   return(major);
 }
+#endif
 
 cdrom_drive *cdda_identify_scsi(const char *generic_device, 
 				const char *ioctl_device, int messagedest,
@@ -460,6 +496,7 @@
 	       generic_device);
       return(NULL);
     }
+#ifdef __linux__
     if((int)(g_st.st_rdev>>8)!=SCSI_GENERIC_MAJOR){
       if((int)(g_st.st_rdev>>8)!=SCSI_CDROM_MAJOR){
 	idmessage(messagedest,messages,"\t\t%s is not a SCSI device",
@@ -471,6 +508,7 @@
 	ioctl_device=temp;
       }
     }
+#endif
   }
   if(ioctl_device){
     if(stat(ioctl_device,&i_st)){
@@ -478,6 +516,7 @@
 	       ioctl_device);
       return(NULL);
     }
+#ifdef __linux__
     if((int)(i_st.st_rdev>>8)!=SCSI_CDROM_MAJOR){
       if((int)(i_st.st_rdev>>8)!=SCSI_GENERIC_MAJOR){
 	idmessage(messagedest,messages,"\t\t%s is not a SCSI device",
@@ -489,6 +528,7 @@
 	ioctl_device=temp;
       }
     }
+#endif
   }
 
   /* we need to resolve any symlinks for the lookup code to work */
@@ -505,6 +545,7 @@
   }
 
   if(!generic_device || !ioctl_device){
+#ifdef __linux__
     if(generic_device){
       ioctl_device=
 	scsi_match(generic_device,scsi_cdrom_prefixes,
@@ -520,6 +561,9 @@
       if(!generic_device)	
 	goto cdda_identify_scsi_fail;
     }
+#else
+    goto cdda_identify_scsi_fail;
+#endif
   }
   
   idmessage(messagedest,messages,"\t\tgeneric device: %s",generic_device);
@@ -556,6 +600,7 @@
 
     type=(int)(i_st.st_rdev>>8);
 
+#ifdef __linux__
     if(type==SCSI_CDROM_MAJOR){
       if (!S_ISBLK(i_st.st_mode)) {
 	idmessage(messagedest,messages,"\t\tSCSI CDROM device %s not a "
@@ -567,8 +612,10 @@
 		"major number",ioctl_device);
       goto cdda_identify_scsi_fail;
     }
+#endif
   }
 
+#ifdef __linux__
   if((int)(g_st.st_rdev>>8)==SCSI_GENERIC_MAJOR){
     if (!S_ISCHR(g_st.st_mode)) {
       idmessage(messagedest,messages,"\t\tGeneric SCSI device %s not a "
@@ -580,6 +627,7 @@
 	      "major number",generic_device);
     goto cdda_identify_scsi_fail;
   }
+#endif
   
 
   d=calloc(1,sizeof(cdrom_drive));
@@ -590,6 +638,7 @@
   d->bigendianp=-1; /* We don't know yet... */
   d->nsectors=-1;
 
+#ifdef __linux__
   version=verify_SG_version(d,messagedest,messages);
   switch(version){
   case -1:case 0:case 1:
@@ -599,6 +648,9 @@
     d->interface=GENERIC_SCSI;
     break;
   }
+#else
+  d->interface=GENERIC_SCSI;
+#endif
 
   /* malloc our big buffer for scsi commands */
   d->sg=malloc(MAX_BIG_BUFF_SIZE);
@@ -617,7 +669,16 @@
 
   /* It would seem some TOSHIBA CDROMs gets things wrong */
  
-  if (!strncmp (p + 8, "TOSHIBA", 7) &&
+#ifndef TYPE_DISK
+#define TYPE_DISK	0	/* direct */
+#endif
+#ifndef TYPE_WORM
+#define TYPE_WORM	4	/* write once, read many */
+#endif
+#ifndef TYPE_ROM
+#define TYPE_ROM	5	/* CD-ROM */
+#endif
+  if (p && !strncmp (p + 8, "TOSHIBA", 7) &&
       !strncmp (p + 16, "CD-ROM", 6) &&
       p[0] == TYPE_DISK) {
     p[0] = TYPE_ROM;
