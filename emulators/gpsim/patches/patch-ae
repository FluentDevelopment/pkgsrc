$NetBSD: patch-ae,v 1.3 2004/05/02 20:08:14 bouyer Exp $

--- src/uart.cc.orig	2004-01-31 03:58:04.000000000 +0100
+++ src/uart.cc	2004-04-30 18:56:31.000000000 +0200
@@ -139,11 +139,16 @@
       cout << "TXSTA - enabling transmitter\n";
       if(txreg) {
 	cout << " TXSTA - does have a txreg\n";
-	if(txreg->is_empty())
 	  txreg->empty();
-	else
+#if 0
+	if(txreg->is_empty()) {
+	  txreg->empty();
+	} else {
+          cout << "start_transmitting1" << endl;
 	  start_transmitting();
       }
+#endif
+      }
     } else 
       stop_transmitting();
   }
@@ -431,47 +436,53 @@
 void _RCSTA::receive_a_bit(unsigned int bit)
 {
 
-  if(bit_count)
-    {
+  // If we're waiting for the start bit and this isn't it then
+  // we don't need to look any further
+  // cout << "receive_a_bit state " << state << "bit " << bit << endl;
+  if( state == RCSTA_MAYBE_START) {
+    if (bit)
+      state = RCSTA_WAITING_FOR_START;
+    else
+      state = RCSTA_RECEIVING;
+    return;
+  }
+  if (bit_count == 0) {
+    // we should now have the stop bit
+    if (bit) {
+      // got the stop bit
+      // If the rxreg has data from a previous reception then
+      // we have a receiver overrun error.
+      // cout << "rcsta.rsr is full\n";
+
+      if((value & RX9) == 0)
+        rsr >>= 1;
+
+      // copy the rsr to the fifo
+      if(rcreg)
+        rcreg->push( rsr & 0xff);
+       //cout << "_RCSTA::receive_a_bit received 0x" << (rsr & 0xff) << endl;
+
+    } else {
+      //not stop bit; discard the data and go back receiving
+    }
+    // If we're continuously receiving, then set up for the next byte.
+    // FIXME -- may want to set a half bit delay before re-starting...
+    if(value & CREN)
+      start_receiving();
+    else
+      state = RCSTA_DISABLED;
+    return;
+  }
 
-      // If we're waiting for the start bit and this isn't it then
-      // we don't need to look any further
-      if( (state == RCSTA_WAITING_FOR_START) && bit)
-	return;
-
-      // Copy the bit into the Receive Shift Register
-      if(bit)
-	rsr |= 1<<9;
-
-      //cout << "Receive bit #" << bit_count << ": " << (rsr&(1<<9)) << '\n';
-
-      rsr >>= 1;
-
-      if(--bit_count == 0)
-	{
-	  // rsr is full.
-
-	  // If the rxreg has data from a previous reception then
-	  // we have a receiver overrun error.
-	  //cout << "rcsta.rsr is full\n";
-
-	  if((value & RX9) == 0)
-	    rsr >>= 1;
-
-	  // copy the rsr to the fifo
-	  if(rcreg)
-	    rcreg->push( rsr & 0xff);
-
-	  // If we're continuously receiving, then set up for the next byte.
-	  // FIXME -- may want to set a half bit delay before re-starting...
-	  if(value & CREN)
-	    start_receiving();
-	  else
-	    state = RCSTA_DISABLED;
 
-	}
+  // Copy the bit into the Receive Shift Register
+  if(bit)
+    rsr |= 1<<9;
 
-    }
+  //cout << "Receive bit #" << bit_count << ": " << (rsr&(1<<9)) << '\n';
+
+  rsr >>= 1;
+  bit_count--;
 
 }
 
@@ -494,11 +505,11 @@
   // Is this a 9-bit data reception?
   if(value & RX9)
     {
-      bit_count = 10;
+      bit_count = 9;
     }
   else
     {
-      bit_count = 9;
+      bit_count = 8;
     }
 
   state = RCSTA_WAITING_FOR_START;
@@ -526,11 +537,11 @@
   if(txsta && (txsta->value & _TXSTA::BRGH))
     set_callback_break(BRGH_FIRST_MID_SAMPLE);
   else
-    set_callback_break(BRGH_FIRST_MID_SAMPLE);
+    set_callback_break(BRGL_FIRST_MID_SAMPLE);
 
   sample = 0;
-  state = RCSTA_WAITING_MID1;
-
+  sample_state = RCSTA_WAITING_MID1;
+  state = RCSTA_MAYBE_START;
 }
 
 void _RCSTA::callback(void)
@@ -538,7 +549,7 @@
 
   //cout << "RCSTA callback " << (cycles.value) << '\n';
 
-  switch(state) {
+  switch(sample_state) {
   case RCSTA_WAITING_MID1:
     if(uart_port->get_bit(rx_bit))
       sample++;
@@ -548,7 +559,7 @@
     else
       set_callback_break(BRGL_SECOND_MID_SAMPLE - BRGL_FIRST_MID_SAMPLE);
 
-    state = RCSTA_WAITING_MID2;
+    sample_state = RCSTA_WAITING_MID2;
 
     break;
 
@@ -561,7 +572,7 @@
     else
       set_callback_break(BRGL_THIRD_MID_SAMPLE - BRGL_SECOND_MID_SAMPLE);
 
-    state = RCSTA_WAITING_MID3;
+    sample_state = RCSTA_WAITING_MID3;
 
     break;
 
@@ -573,13 +584,13 @@
     sample = 0;
 
     // If this wasn't the last bit then go ahead and set a break for the next bit.
-    if(state==RCSTA_WAITING_MID3) {
+    if(state==RCSTA_RECEIVING) {
       if(txsta && (txsta->value & _TXSTA::BRGH))
 	set_callback_break(TOTAL_BRGH_STATES -(BRGH_THIRD_MID_SAMPLE - BRGH_FIRST_MID_SAMPLE));
       else
 	set_callback_break(TOTAL_BRGL_STATES -(BRGL_THIRD_MID_SAMPLE - BRGL_FIRST_MID_SAMPLE));
 
-      state = RCSTA_WAITING_MID1;
+      sample_state = RCSTA_WAITING_MID1;
     }
 
     break;
