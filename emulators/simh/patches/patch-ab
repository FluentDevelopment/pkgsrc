$NetBSD: patch-ab,v 1.1 2002/10/19 21:38:10 thorpej Exp $

--- sim_ether.c.orig	Sat Oct 19 14:26:01 2002
+++ sim_ether.c	Sat Oct 19 14:26:10 2002
@@ -70,6 +70,7 @@
          msg, dst, src, *proto, packet->len);
 }
 
+#ifndef __NetBSD__
 char* eth_getname(int number, char* name)
 {
 #define ETH_SUPPORTED_DEVICES 10
@@ -80,6 +81,7 @@
   strcpy(name, list[number].name);
   return name;
 }
+#endif /* ! __NetBSD__ */
 
 void eth_zero(ETH_DEV* dev)
 {
@@ -89,7 +91,7 @@
 
 /* First, all the non-implemented versions */
 
-#if !defined (WIN32) && !defined(linux)
+#if !defined (WIN32) && !defined(linux) && !defined(__NetBSD__)
 t_stat eth_open (ETH_DEV* dev, char* name)
   {return SCPE_NOFNC;}
 t_stat eth_close (ETH_DEV* dev)
@@ -110,9 +112,13 @@
 #ifdef WIN32
 #include <packet32.h>
 #endif /*WIN32*/
-#ifdef linux
+#ifdef __NetBSD__
+#include <sys/ioctl.h>
+#include <net/bpf.h>
+#endif /* __NetBSD__ */
+#if defined(linux) || defined(__NetBSD__)
 #include <fcntl.h>
-#endif /*linux*/
+#endif /*linux || __NetBSD__*/
 
 t_stat eth_open(ETH_DEV* dev, char* name)
 {
@@ -124,22 +130,34 @@
   /* initialize device */
   eth_zero(dev);
 
+#ifndef __NetBSD__
   /* translate name of type "ethX" */
   if ((strlen(name) == 4) && isdigit(name[3])) {
     num = atoi(&name[3]);
     savname = eth_getname(num, temp);
   }
+#endif /* ! __NetBSD__ */
 
   /* attempt to connect device */
-  dev->handle = (void*) pcap_open_live(savname, BUFSIZ, ETH_PROMISC, /*ETH_TIMEOUT*/-1, errbuf);
+  dev->handle = (void*) pcap_open_live(savname, ETH_MAX_PACKET, ETH_PROMISC, /*ETH_TIMEOUT*/-1, errbuf);
 
-  if (!dev->handle) return SCPE_OPENERR; /* can't open device */
+  if (!dev->handle) {
+    printf("pcap_open_live: %s\n", errbuf);
+    return SCPE_OPENERR; /* can't open device */
+  }
 
   /* save name of device */
   dev->name = malloc(strlen(savname)+1);
   strcpy(dev->name, savname);
 
-#ifdef linux
+#ifdef __NetBSD__
+  /* tell the kernel that the header is fully-formed when it gets it.  this
+     is required in order to fake the src address.  */
+  i = 1;
+  ioctl(pcap_fileno(dev->handle), BIOCSHDRCMPLT, &i);
+#endif /* __NetBSD__ */
+
+#if defined(linux) || defined(__NetBSD__)
   /* set file non-blocking */
   fcntl(pcap_fileno(dev->handle), F_SETFL, fcntl(pcap_fileno(dev->handle), F_GETFL, 0) | O_NONBLOCK);
 #endif /*linux*/
@@ -373,4 +391,53 @@
 
 #endif /*linux*/
 
+#ifdef __NetBSD__
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <net/if_dl.h>
+#include <net/if_types.h>
+#include <ifaddrs.h>
+#include <string.h>
+
+int pcap_sendpacket(pcap_t* handle, u_char* msg, int len)
+{
+  return (write(pcap_fileno(handle), msg, len) == len)?0:-1;
+}
+
+int PacketGetAdapterNames(char* buffer, int* size)
+{
+  const struct sockaddr_dl *sdl;
+  struct ifaddrs *ifap, *ifa;
+  char *p;
+  int ptr = 0;
+
+  if (getifaddrs(&ifap) != 0) {
+    *size = 0;
+    return (0);
+  }
+
+  p = NULL;
+  for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+    if (ifa->ifa_addr->sa_family != AF_LINK)
+      continue;
+    if (p && strcmp(p, ifa->ifa_name) == 0)
+      continue;
+    sdl = (const struct sockaddr_dl *) ifa->ifa_addr;
+    if (sdl->sdl_type != IFT_ETHER)
+      continue;
+
+    strcpy(buffer+ptr, ifa->ifa_name);
+    ptr += strlen(ifa->ifa_name)+1;
+  }
+
+  freeifaddrs(ifap);
+
+  buffer[ptr++] = '\0';
+  buffer[ptr++] = '\0';
+  *size = ptr;
+
+  return (ptr);
+}
 
+#endif /* __NetBSD__ */
