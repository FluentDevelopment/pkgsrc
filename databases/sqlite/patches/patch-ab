$NetBSD: patch-ab,v 1.2 2001/11/19 00:41:06 reinoud Exp $

--- ../sqlite/src/btree.c.orig	Sat Nov 10 14:51:08 2001
+++ ../sqlite/src/btree.c
@@ -60,7 +60,7 @@
 ** The uptr type must be big enough to hold a pointer.
 ** Change these typedefs when porting to new architectures.
 */
-typedef unsigned int uptr;
+typedef unsigned long long int uptr;
 
 /* There are already defined in sqliteInt.h...
 ** typedef unsigned int u32;
@@ -829,7 +829,7 @@
 int sqliteBtreeCursor(Btree *pBt, int iTable, int wrFlag, BtCursor **ppCur){
   int rc;
   BtCursor *pCur;
-  int nLock;
+  long long int nLock;
 
   if( pBt->page1==0 ){
     rc = lockBtree(pBt);
@@ -852,7 +852,7 @@
   if( rc!=SQLITE_OK ){
     goto create_cursor_exception;
   }
-  nLock = (int)sqliteHashFind(&pBt->locks, 0, iTable);
+  nLock = (long long int)sqliteHashFind(&pBt->locks, 0, iTable);
   if( nLock<0 || (nLock>0 && wrFlag) ){
     rc = SQLITE_LOCKED;
     goto create_cursor_exception;
@@ -886,7 +886,7 @@
 ** when the last cursor is closed.
 */
 int sqliteBtreeCloseCursor(BtCursor *pCur){
-  int nLock;
+  long long int nLock;
   Btree *pBt = pCur->pBt;
   if( pCur->pPrev ){
     pCur->pPrev->pNext = pCur->pNext;
@@ -900,7 +900,7 @@
     sqlitepager_unref(pCur->pPage);
   }
   unlockBtreeIfUnused(pBt);
-  nLock = (int)sqliteHashFind(&pBt->locks, 0, pCur->pgnoRoot);
+  nLock = (long long int)sqliteHashFind(&pBt->locks, 0, pCur->pgnoRoot);
   assert( nLock!=0 || sqlite_malloc_failed );
   nLock = nLock<0 ? 0 : nLock-1;
   sqliteHashInsert(&pBt->locks, 0, pCur->pgnoRoot, (void*)nLock);
@@ -2293,11 +2293,11 @@
 */
 int sqliteBtreeClearTable(Btree *pBt, int iTable){
   int rc;
-  int nLock;
+  long long int nLock;
   if( !pBt->inTrans ){
     return SQLITE_ERROR;  /* Must start a transaction first */
   }
-  nLock = (int)sqliteHashFind(&pBt->locks, 0, iTable);
+  nLock = (long long int)sqliteHashFind(&pBt->locks, 0, iTable);
   if( nLock ){
     return SQLITE_LOCKED;
   }
