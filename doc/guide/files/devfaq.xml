<!-- $NetBSD: devfaq.xml,v 1.3 2006/06/22 07:30:38 rillig Exp $ -->

<chapter id="devfaq"> <?dbhtml filename="devfaq.html"?>
<title>Frequently Asked Questions</title>

	<para>This section contains the answers to questions that may
	arise when you are writing a package. If you don't find your
	question answered here, first have a look in the other chapters,
	and if you still don't have the answer, ask on the
	<literal>pkgsrc-users</literal> mailing list.</para>

<qandaset>
<qandaentry>

	<question><para>What is the difference between
	<varname>MAKEFLAGS</varname>, <varname>.MAKEFLAGS</varname> and
	<varname>MAKE_FLAGS</varname>?</para></question>

	<answer><para><varname>MAKEFLAGS</varname> are the flags passed
	to the pkgsrc-internal invocations of &man.make.1;, while
	<varname>MAKE_FLAGS</varname> are the flags that are passed to
	the <varname>MAKE_PROGRAM</varname> when building the
	package. [FIXME: What is .MAKEFLAGS for?]</para></answer>

</qandaentry>
<qandaentry>

	<question><para>What is the difference between
	<varname>MAKE</varname>, <varname>GMAKE</varname> and
	<varname>MAKE_PROGRAM</varname>?</para></question>

	<answer><para><varname>MAKE</varname> is the path to the
	&man.make.1; program that is used in the pkgsrc
	infrastructure. <varname>GMAKE</varname> is the path to GNU
	Make, but you need to say <varname>USE_TOOLS+=gmake</varname> to
	use that. <varname>MAKE_PROGRAM</varname> is the path to the
	Make program that is used for building the
	package.</para></answer>

</qandaentry>
<qandaentry>

	<question><para>What is the difference between
	<varname>CC</varname>, <varname>PKG_CC</varname> and
	<varname>PKGSRC_COMPILER</varname>?</para></question>

	<answer><para><varname>CC</varname> is the path to the real C
	compiler, which can be configured by the pkgsrc user.
	<varname>PKG_CC</varname> is the path to the compiler wrapper.
	<varname>PKGSRC_COMPILER</varname> is <emphasis>not</emphasis> a
	path to a compiler, but the type of compiler that should be
	used. See <filename>mk/compiler.mk</filename> for more
	information about the latter variable.</para></answer>

</qandaentry>
<qandaentry>

	<question><para>What is the difference between
	<varname>BUILDLINK_LDFLAGS</varname>,
	<varname>BUILDLINK_LDADD</varname> and
	<varname>BUILDLINK_LIBS</varname>?</para></question>

	<answer><para>[FIXME]</para></answer>

</qandaentry>
<qandaentry>

	<question><para>Why does <command>make show-var
	VARNAME=BUILDLINK_PREFIX.<replaceable>foo</replaceable></command>
	say it's empty?</para></question>

	<answer><para>For optimization reasons, some variables are only
	available in the <quote>wrapper</quote> phase and later. To
	<quote>simulate</quote> the wrapper phase, append
	<command>PKG_PHASE=wrapper</command> to the above
	command.</para></answer>

</qandaentry>
<qandaentry>

	<question><para>What does
	<literal>${MASTER_SITE_SOURCEFORGE:=package/}</literal> mean? I
	don't understand the <literal>:=</literal> inside
	it.</para></question>

	<answer><para>The <literal>:=</literal> is not really an
	assignment operator, like you might expect at first sight.
	Instead, it is a degenerate form of
	<literal>${LIST:<replaceable>old_string</replaceable>=<replaceable>new_string</replaceable>}</literal>,
	which is documented in the &man.make.1; man page and which you
	may have seen as in <literal>${SRCS:.c=.o}</literal>. In the
	case of <varname>MASTER_SITE_*</varname>,
	<replaceable>old_string</replaceable> is the empty string and
	<replaceable>new_string</replaceable> is
	<literal>package/</literal>. That's where the
	<literal>:</literal> and the <literal>=</literal> fall
	together.</para></answer>

</qandaentry>
</qandaset>
</chapter>
