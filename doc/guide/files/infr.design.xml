<!-- $NetBSD: infr.design.xml,v 1.1 2006/05/12 23:03:22 rillig Exp $ -->

<chapter id="infr.design"> <?dbhtml filename="infr.design.html"?>
<title>Design of the pkgsrc infrastructure</title>

	<para>The pkgsrc infrastructure consists of many small Makefile
	fragments. Each such fragment needs a properly specified
	interface. This chapter explains how such an interface looks
	like.</para>

<!--
<sect1 id="infr.intro">
<title>Introduction</title>

</sect1>
-->

<sect1 id="infr.var">
<title>Variable evaluation</title>

<sect2 id="infr.var.load">
<title>At load time</title>

	<para>Variable evaluation takes place either at load time or at
	runtime, depending on the context in which they occur. The
	contexts where variables are evaluated at load time are:</para>

	<itemizedlist>

	<listitem><para>The right hand side of the <literal>:=</literal>
	and <literal>!=</literal> operators,</para></listitem>

	<listitem><para>Make directives like <literal>.if</literal> or
	<literal>.for</literal>,</para></listitem>

	<listitem><para>Dependency lines.</para></listitem>

	</itemizedlist>

	<para>A special exception are references to the iteration
	variables of <literal>.for</literal> loops, which are expanded
	inline, no matter in which context they appear.</para>

	<para>As the values of variables may change during load time,
	care must be taken not to evaluate them by accident. Typical
	examples for variables that should not be evaluated at load time
	are <varname>DEPENDS</varname> and
	<varname>CONFIGURE_ARGS</varname>. To make the effect more
	clear, here is an example:</para>

	<programlisting>
    CONFIGURE_ARGS=         # none
    CFLAGS=                 -O
    CONFIGURE_ARGS+=        CFLAGS=${CFLAGS:Q}

    CONFIGURE_ARGS:=        ${CONFIGURE_ARGS}

    CFLAGS+=                -Wall
	</programlisting>

	<para>This code shows how the use of the <literal>:=</literal>
	operator can quickly lead to unexpected results. The first
	paragraph is fairly common code. The second paragraph evaluates
	the <varname>CONFIGURE_ARGS</varname> variable, which results in
	<literal>CFLAGS=-O</literal>. In the third paragraph, the
	<literal>-Wall</literal> is appended to the
	<varname>CFLAGS</varname>, but this addition will not appear in
	<varname>CONFIGURE_ARGS</varname>. In actual code, the three
	paragraphs from above typically occur in completely unrelated
	files.</para>

</sect2>
<sect2 id="infr.var.run">
<title>At runtime</title>

	<para>After all the files have been loaded, the values of the
	variables cannot be changed anymore. Variables that are used in
	the shell commands are expanded at this point.</para>

</sect2>
</sect1>

<sect1 id="infr.design.intf">
<title>Designing interfaces for Makefile fragments</title>

	<para>Most of the <filename>.mk</filename> files fall into one
	of the following classes. Cases where a file falls into more
	than one class should be avoided as it often leads to subtle
	bugs.</para>

<sect2 id="infr.design.intf.proc">
<title>Procedures with parameters</title>

	<para>In a traditional imperative programming language some of
	the <filename>.mk</filename> files could be described as
	procedures. They take some input parameters and&mdash;after
	inclusion&mdash;provide a result in output parameters. Since all
	variables in <filename>Makefile</filename>s have global scope
	care must be taken not to use parameter names that have already
	another meaning. For example, <varname>PKGNAME</varname> is a
	bad choice for a parameter name.</para>

	<para>Procedures are completely evaluated at preprocessing time.
	That is, when calling a procedure all input parameters must be
	completely resolvable. For example,
	<varname>CONFIGURE_ARGS</varname> should never be an input
	parameter since it is very likely that further text will be
	added after calling the procedure, which would effectively apply
	the procedure to only a part of the variable. Also, references
	to other variables wit will be modified after calling the
	procedure.</para>

	<para>A procedure can declare its output parameters either as
	suitable for use in preprocessing directives or as only
	available at runtime. The latter alternative is for variables
	that contain references to other runtime variables.</para>

	<para>Procedures shall be written such that it is possible to
	call the procedure more than once. That is, the file must not
	contain multiple-inclusion guards.</para>

	<para>Examples for procedures are
	<filename>mk/bsd.options.mk</filename> and
	<filename>mk/buildlink3/bsd.builtin.mk</filename>. To express
	that the parameters are evaluated at load time, they should be
	assigned using the <literal>:=</literal> operator, which should
	be used only for this purpose.</para>

</sect2>
<sect2 id="infr.design.intf.action">
<title>Actions taken on behalf of parameters</title>

	<para>Action files take some input parameters and may define
	runtime variables. They shall not define loadtime variables.
	There are action files that are included implicitly by the
	pkgsrc infrastructure, while other must be included
	explicitly.</para>

	<para>An example for action files is
	<filename>mk/subst.mk</filename>.</para>

</sect2>
</sect1>
</chapter>
